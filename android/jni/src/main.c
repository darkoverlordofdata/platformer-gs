/* main.c generated by valac 0.34.8, the Vala compiler
 * generated from main.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_video.h>
#include <emscripten.h>

#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;
typedef struct _Game Game;
void game_release (Game* self);
void game_free (Game* self);
Game* game_retain (Game* self);
void game_release (Game* self);
void game_free (Game* self);
Game* game_retain (Game* self);
#define _game_release0(var) ((var == NULL) ? NULL : (var = (game_release (var), NULL)))
#define _SDL_DestroyWindow0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyWindow (var), NULL)))

typedef enum  {
	EXCEPTION_SDLException,
	EXCEPTION_InvalidValue,
	EXCEPTION_MapFileFormat
} Exception;
#define EXCEPTION exception_quark ()
struct _Point2d {
	gdouble x;
	gdouble y;
};


extern gdouble startTime;
gdouble startTime = 0.0;
extern gint lastTick;
gint lastTick = 0;

GQuark exception_quark (void);
gchar* formatTime (gint ticks);
void sdlFailIf (gboolean cond, const gchar* reason);
void game (void);
SDL_Window* sdx_initialize (gint width, gint height, const gchar* name);
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
void game_free (Game* self);
Game* game_new (void);
gdouble sdx_getNow (void);
void sdx_start (void);
void mainloop (void* arg);
static void _mainloop_em_arg_callback_func (void* arg);
void sdx_processEvents (void);
void game_update (Game* self, gint tick);
void game_render (Game* self, gint tick);

extern const Point2d WINDOW_SIZE;

GQuark exception_quark (void) {
	return g_quark_from_static_string ("exception-quark");
}


inline gchar* formatTime (gint ticks) {
	gchar* result = NULL;
	gint mins = 0;
	gint _tmp0_ = 0;
	gint secs = 0;
	gint _tmp1_ = 0;
	gchar* _tmp2_ = NULL;
	_tmp0_ = ticks;
	mins = (_tmp0_ / 50) / 60;
	_tmp1_ = ticks;
	secs = (_tmp1_ / 50) % 60;
	_tmp2_ = g_strdup_printf ("%02d:%02d", (gint) mins, (gint) secs);
	result = _tmp2_;
	return result;
}


inline void sdlFailIf (gboolean cond, const gchar* reason) {
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (reason != NULL);
	_tmp0_ = cond;
	if (_tmp0_) {
		const gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		GError* _tmp7_ = NULL;
		GError* _tmp8_ = NULL;
		_tmp1_ = reason;
		_tmp2_ = g_strconcat (_tmp1_, ", SDL error: ", NULL);
		_tmp3_ = _tmp2_;
		_tmp4_ = SDL_GetError ();
		_tmp5_ = g_strconcat (_tmp3_, _tmp4_, NULL);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_error_new_literal (EXCEPTION, EXCEPTION_SDLException, _tmp6_);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		_g_free0 (_tmp3_);
		_inner_error_ = _tmp8_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void _mainloop_em_arg_callback_func (void* arg) {
	mainloop (arg);
}


void game (void) {
	SDL_Window* window = NULL;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	SDL_Window* _tmp2_ = NULL;
	Game* game = NULL;
	Game* _tmp3_ = NULL;
	gdouble _tmp4_ = 0.0;
	_tmp0_ = WINDOW_SIZE.x;
	_tmp1_ = WINDOW_SIZE.y;
	_tmp2_ = sdx_initialize ((gint) _tmp0_, (gint) _tmp1_, "Shmupwarz");
	window = _tmp2_;
	_tmp3_ = game_new ();
	game = _tmp3_;
	_tmp4_ = sdx_getNow ();
	startTime = _tmp4_;
	lastTick = 0;
	sdx_start ();
	emscripten_set_main_loop_arg (_mainloop_em_arg_callback_func, game, 0, 1);
	_game_release0 (game);
	_SDL_DestroyWindow0 (window);
}


static gpointer _game_retain0 (gpointer self) {
	return self ? game_retain (self) : NULL;
}


void mainloop (void* arg) {
	Game* game = NULL;
	void* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	gint newTick = 0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gint _tmp10_ = 0;
	Game* _tmp11_ = NULL;
	gint _tmp12_ = 0;
	_tmp0_ = arg;
	_tmp1_ = _game_retain0 ((Game*) _tmp0_);
	game = _tmp1_;
	sdx_processEvents ();
	_tmp2_ = sdx_getNow ();
	_tmp3_ = startTime;
	newTick = (gint) ((_tmp2_ - _tmp3_) * 50);
	{
		gint tick = 0;
		gint _tmp4_ = 0;
		_tmp4_ = lastTick;
		tick = _tmp4_ + 1;
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				gint _tmp7_ = 0;
				Game* _tmp8_ = NULL;
				gint _tmp9_ = 0;
				if (!_tmp5_) {
					gint _tmp6_ = 0;
					_tmp6_ = tick;
					tick = _tmp6_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp7_ = newTick;
				if (!(tick <= _tmp7_)) {
					break;
				}
				_tmp8_ = game;
				_tmp9_ = tick;
				game_update (_tmp8_, _tmp9_);
			}
		}
	}
	_tmp10_ = newTick;
	lastTick = _tmp10_;
	_tmp11_ = game;
	_tmp12_ = lastTick;
	game_render (_tmp11_, _tmp12_);
	_game_release0 (game);
}



