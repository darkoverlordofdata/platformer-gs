/* Game.c generated by valac 0.34.8, the Vala compiler
 * generated from Game.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_rect.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_pixels.h>


#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;
typedef struct _Game Game;
typedef struct _Map Map;

#define TYPE_CAMERA (camera_get_type ())
typedef Vector2d Camera;

#define TYPE_CAMERA_TYPE (camera_type_get_type ())
typedef struct _Entities Entities;

#define TYPE_ENTITY (entity_get_type ())

#define TYPE_CATEGORY (category_get_type ())

#define TYPE_ACTOR (actor_get_type ())

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;
typedef struct _sdxgraphicsSprite sdxgraphicsSprite;

#define TYPE_TIMER (timer_get_type ())
typedef struct _Timer Timer;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;
typedef struct _Entity Entity;
typedef struct _Systems Systems;
typedef struct _Hud Hud;
void map_release (Map* self);
void map_free (Map* self);
Map* map_retain (Map* self);
#define _map_release0(var) ((var == NULL) ? NULL : (var = (map_release (var), NULL)))
void entities_release (Entities* self);
void entities_free (Entities* self);
Entities* entities_retain (Entities* self);
#define _entities_release0(var) ((var == NULL) ? NULL : (var = (entities_release (var), NULL)))
void systems_release (Systems* self);
void systems_free (Systems* self);
Systems* systems_retain (Systems* self);
#define _systems_release0(var) ((var == NULL) ? NULL : (var = (systems_release (var), NULL)))
void hud_release (Hud* self);
void hud_free (Hud* self);
Hud* hud_retain (Hud* self);
#define _hud_release0(var) ((var == NULL) ? NULL : (var = (hud_release (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

struct _Vector2d {
	gdouble x;
	gdouble y;
};

typedef enum  {
	CAMERA_TYPE_FLUID_CAMERA,
	CAMERA_TYPE_INNER_CAMERA,
	CAMERA_TYPE_SIMPLE_CAMERA
} CameraType;

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_PLAYER,
	CATEGORY_BONUS
} Category;

typedef enum  {
	ACTOR_DEFAULT,
	ACTOR_BACKGROUND,
	ACTOR_TEXT,
	ACTOR_PLAYER,
	ACTOR_BONUS,
	ACTOR_HUD
} Actor;

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Timer {
	gint begin;
	gint finish;
	gint best;
};

struct _Health {
	gint curHealth;
	gint maxHealth;
};

struct _Entity {
	gint id;
	gchar* name;
	gboolean active;
	Category category;
	Actor actor;
	Point2d position;
	SDL_Rect bounds;
	sdxgraphicsSprite* sprite;
	Vector2d* size;
	Vector2d* scale;
	SDL_Color* tint;
	Timer* expires;
	Health* health;
	Vector2d* velocity;
};

struct _Game {
	gint retainCount__;
	Map* map;
	Camera camera;
	CameraType cameraType;
	Entities* factory;
	Entity* entities;
	gint entities_length1;
	Systems* system;
	Hud* hud;
	Entity* player;
	GList* sprites;
};


extern SDL_Color sdx_bgdColor;

GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
void game_free (Game* self);
void map_free (Map* self);
GType camera_get_type (void) G_GNUC_CONST;
Camera* camera_dup (const Camera* self);
void camera_free (Camera* self);
GType camera_type_get_type (void) G_GNUC_CONST;
void entities_free (Entities* self);
GType entity_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
void sdx_graphics_sprite_free (sdxgraphicsSprite* self);
GType timer_get_type (void) G_GNUC_CONST;
Timer* timer_dup (const Timer* self);
void timer_free (Timer* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
void systems_free (Systems* self);
void hud_free (Hud* self);
static void game_instance_init (Game * self);
static void _vala_Entity_array_free (Entity* array, gint array_length);
Game* game_retain (Game* self);
void game_release (Game* self);
void game_free (Game* self);
Game* game_new (void);
void sdx_setResource (const gchar* path);
void sdx_setDefaultFont (const gchar* path, gint size);
Entities* entities_new (void);
Map* map_new (const gchar* mapPath);
void entities_createBerry (Entities* self, Entity* result);
void entities_createPlayer (Entities* self, Entity* result);
Systems* systems_new (Game* game);
Hud* hud_new (void);
void game_update (Game* self, gint tick);
void sdx_update (void);
void systems_physics (Systems* self, Entity** player, gint tick);
void systems_camera (Systems* self, Entity** player, gint tick);
void systems_logic (Systems* self, Entity** player, gint tick);
void game_render (Game* self, gint tick);
void sdx_begin (void);
void map_render (Map* self, Camera* camera);
void sdx_graphics_sprite_render (sdxgraphicsSprite* self, gint x, gint y, SDL_Rect* clip);
void hud_render (Hud* self, Entity** player, gint tick);
void sdx_end (void);

const Vector2d UNUSED_Game = {(gdouble) 0, (gdouble) 0};
const SDL_Point WINDOW_SIZE = {1280, 720};
extern const SDL_Color SDX_COLOR_LiteSlateBlue;

static void _vala_Entity_array_free (Entity* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			entity_destroy (&array[i]);
		}
	}
	g_free (array);
}


Game* game_retain (Game* self) {
	Game* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->retainCount__), 1);
	result = self;
	return result;
}


void game_release (Game* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->retainCount__));
	if (_tmp0_) {
		game_free (self);
	}
}


Game* game_new (void) {
	Game* self;
	Entities* _tmp0_ = NULL;
	Map* _tmp1_ = NULL;
	Entities* _tmp2_ = NULL;
	Entity _tmp3_ = {0};
	Entities* _tmp4_ = NULL;
	Entity _tmp5_ = {0};
	Entity* _tmp6_ = NULL;
	Systems* _tmp7_ = NULL;
	Hud* _tmp8_ = NULL;
	Entity* _tmp9_ = NULL;
	gint _tmp9__length1 = 0;
	self = g_slice_new0 (Game);
	game_instance_init (self);
	self->cameraType = CAMERA_TYPE_SIMPLE_CAMERA;
	sdx_setResource ("/darkoverlordofdata/platformer");
	sdx_setDefaultFont ("assets/OpenDyslexic-Bold.otf", 28);
	sdx_bgdColor = SDX_COLOR_LiteSlateBlue;
	_tmp0_ = entities_new ();
	_entities_release0 (self->factory);
	self->factory = _tmp0_;
	_tmp1_ = map_new ("assets/default.json");
	_map_release0 (self->map);
	self->map = _tmp1_;
	_tmp2_ = self->factory;
	entities_createBerry (_tmp2_, &_tmp3_);
	_tmp4_ = self->factory;
	entities_createPlayer (_tmp4_, &_tmp5_);
	_tmp6_ = g_new0 (Entity, 2);
	_tmp6_[0] = _tmp3_;
	_tmp6_[1] = _tmp5_;
	self->entities = (_vala_Entity_array_free (self->entities, self->entities_length1), NULL);
	self->entities = _tmp6_;
	self->entities_length1 = 2;
	_tmp7_ = systems_new (self);
	_systems_release0 (self->system);
	self->system = _tmp7_;
	_tmp8_ = hud_new ();
	_hud_release0 (self->hud);
	self->hud = _tmp8_;
	_tmp9_ = self->entities;
	_tmp9__length1 = self->entities_length1;
	self->player = &_tmp9_[1];
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				Entity* _tmp12_ = NULL;
				gint _tmp12__length1 = 0;
				Entity* _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp14_ = 0;
				if (!_tmp10_) {
					gint _tmp11_ = 0;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp10_ = FALSE;
				_tmp12_ = self->entities;
				_tmp12__length1 = self->entities_length1;
				if (!(i <= (_tmp12__length1 - 1))) {
					break;
				}
				_tmp13_ = self->entities;
				_tmp13__length1 = self->entities_length1;
				_tmp14_ = i;
				self->sprites = g_list_append (self->sprites, &_tmp13_[_tmp14_]);
			}
		}
	}
	return self;
}


void game_update (Game* self, gint tick) {
	Systems* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	Systems* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	Systems* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	g_return_if_fail (self != NULL);
	sdx_update ();
	_tmp0_ = self->system;
	_tmp1_ = tick;
	systems_physics (_tmp0_, &self->player, _tmp1_);
	_tmp2_ = self->system;
	_tmp3_ = tick;
	systems_camera (_tmp2_, &self->player, _tmp3_);
	_tmp4_ = self->system;
	_tmp5_ = tick;
	systems_logic (_tmp4_, &self->player, _tmp5_);
}


void game_render (Game* self, gint tick) {
	Map* _tmp0_ = NULL;
	Camera _tmp1_ = {0};
	GList* _tmp2_ = NULL;
	Hud* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	g_return_if_fail (self != NULL);
	sdx_begin ();
	_tmp0_ = self->map;
	_tmp1_ = self->camera;
	map_render (_tmp0_, &_tmp1_);
	_tmp2_ = self->sprites;
	{
		GList* sprite_collection = NULL;
		GList* sprite_it = NULL;
		sprite_collection = _tmp2_;
		for (sprite_it = sprite_collection; sprite_it != NULL; sprite_it = sprite_it->next) {
			Entity* sprite = NULL;
			sprite = sprite_it->data;
			{
				gdouble x = 0.0;
				Entity* _tmp3_ = NULL;
				Point2d _tmp4_ = {0};
				gdouble _tmp5_ = 0.0;
				Camera _tmp6_ = {0};
				gdouble _tmp7_ = 0.0;
				gdouble y = 0.0;
				Entity* _tmp8_ = NULL;
				Point2d _tmp9_ = {0};
				gdouble _tmp10_ = 0.0;
				Camera _tmp11_ = {0};
				gdouble _tmp12_ = 0.0;
				Entity* _tmp13_ = NULL;
				sdxgraphicsSprite* _tmp14_ = NULL;
				gdouble _tmp15_ = 0.0;
				gdouble _tmp16_ = 0.0;
				_tmp3_ = sprite;
				_tmp4_ = (*_tmp3_).position;
				_tmp5_ = _tmp4_.x;
				_tmp6_ = self->camera;
				_tmp7_ = _tmp6_.x;
				x = _tmp5_ - _tmp7_;
				_tmp8_ = sprite;
				_tmp9_ = (*_tmp8_).position;
				_tmp10_ = _tmp9_.y;
				_tmp11_ = self->camera;
				_tmp12_ = _tmp11_.y;
				y = _tmp10_ - _tmp12_;
				_tmp13_ = sprite;
				_tmp14_ = (*_tmp13_).sprite;
				_tmp15_ = x;
				_tmp16_ = y;
				sdx_graphics_sprite_render (_tmp14_, (gint) _tmp15_, (gint) _tmp16_, NULL);
			}
		}
	}
	_tmp17_ = self->hud;
	_tmp18_ = tick;
	hud_render (_tmp17_, &self->player, _tmp18_);
	sdx_end ();
}


static void game_instance_init (Game * self) {
	self->retainCount__ = 1;
	self->sprites = NULL;
}


void game_free (Game* self) {
	_map_release0 (self->map);
	_entities_release0 (self->factory);
	self->entities = (_vala_Entity_array_free (self->entities, self->entities_length1), NULL);
	_systems_release0 (self->system);
	_hud_release0 (self->hud);
	_g_list_free0 (self->sprites);
	g_slice_free (Game, self);
}



