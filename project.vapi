/* project.vapi generated by valac 0.34.8, do not modify. */

using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using GLib;
using sdx.files;
using sdx.files;
using sdx;
using sdx.files;
using sdx.utils;
using sdx.files;
using sdx.graphics;
using GLib;
using sdx.graphics;
using SDL;
using SDL.Video;
using SDLImage;
using SDL;
using SDL.Video;
using SDLTTF;
using sdx.graphics;
using SDL.Video;

namespace platformer {
}
namespace sdx {
	namespace audio {
		[CCode (ref_function = "sdx_audio_sound_retain", unref_function = "sdx_audio_sound_release")]
		[Compact]
		public class Sound {
			public int _retainCount;
			public SDLMixer.Chunk chunk;
			public unowned Sound retain ();
			public void release ();
			public extern void free ();
			public Sound (FileHandle file);
			public void play (int loops = 0);
		}
	}
	namespace files {
		[CCode (ref_function = "sdx_files_file_handle_retain", unref_function = "sdx_files_file_handle_release")]
		[Compact]
		public class FileHandle {
			public int _retainCount;
			public utils.File file;
			public string path;
			public FileType type;
			public unowned FileHandle retain ();
			public void release ();
			public extern void free ();
			public FileHandle (string path, FileType type);
			public SDL.RWops getRWops ();
			public string read ();
			public FileType getType ();
			public string getName ();
			public string getExt ();
			public string getPath ();
			public FileHandle getParent ();
			public bool exists ();
			public FileHandle child (string name);
		}
		public static FileHandle getHandle (string path, FileType type);
		public static FileHandle resource (string path);
		public static FileHandle asset (string path);
		public static FileHandle absolute (string path);
		public static FileHandle relative (string path);
		public static FileHandle @default (string path);
	}
	namespace graphics {
		[CCode (ref_function = "sdx_graphics_bitmap_font_retain", unref_function = "sdx_graphics_bitmap_font_release")]
		[Compact]
		public class BitmapFont {
			public int _retainCount;
			public sdx.utils.Json? dummy2;
			public TextureRegion? dummy;
			public BitmapFontData? data;
			public List<TextureRegion> regions;
			public const int LOG2_PAGE_SIZE = 9;
			public const int PAGE_SIZE = 1 << LOG2_PAGE_SIZE;
			public const int PAGES = 0x10000 / PAGE_SIZE;
			public unowned BitmapFont retain ();
			public void release ();
			public extern void free ();
			public BitmapFont ();
		}
		[CCode (ref_function = "sdx_graphics_glyph_retain", unref_function = "sdx_graphics_glyph_release")]
		[Compact]
		public class Glyph {
			public int _retainCount;
			public int id;
			public int x;
			public int y;
			public int width;
			public int height;
			public double u;
			public double v;
			public double u2;
			public double v2;
			public int xoffset;
			public int yoffset;
			public int xadvance;
			public char[,] kerning;
			public bool fixedWidth;
			public int page;
			public unowned Glyph retain ();
			public void release ();
			public extern void free ();
			public int getKerning (char ch);
			public void setKerning (int ch, int value);
			public Glyph ();
		}
		[CCode (ref_function = "sdx_graphics_bitmap_font_data_retain", unref_function = "sdx_graphics_bitmap_font_data_release")]
		[Compact]
		public class BitmapFontData {
			public int _retainCount;
			public string[] imagePaths;
			public FileHandle fontFile;
			public bool flipped;
			public double padTop;
			public double padRight;
			public double padBottom;
			public double padLeft;
			public double lineHeight;
			public double capHeight;
			public double ascent;
			public double descent;
			public double down;
			public double blankLineScale;
			public double scaleX;
			public double scaleY;
			public bool markupEnabled;
			public double cursorX;
			public Glyph[,] glyphs;
			public Glyph missingGlyph;
			public double spaceWidth;
			public double xHeight;
			public char[] breakChars;
			public char[] xChars;
			public char[] capChars;
			public unowned BitmapFontData retain ();
			public void release ();
			public extern void free ();
			public BitmapFontData (FileHandle? fontFile = null, bool flip = false);
			public void load (FileHandle fontFile, bool flip);
			public void setGlyphRegion (Glyph glyph, TextureRegion region);
			public void setLineHeight (double height);
			public void setGlyph (int ch, Glyph glyph);
			public Glyph getFirstGlyph ();
			public bool hasGlyph (char ch);
			public Glyph getGlyph (char ch);
			public int getWrapIndex (int start, List<Glyph> glyphs);
			public bool isBreakChar (char c);
			public string getImagePath (int index);
		}
		[CCode (ref_function = "sdx_graphics_camera_retain", unref_function = "sdx_graphics_camera_release")]
		[Compact]
		public class Camera {
			[Compact]
			public class InnerCamera : Camera {
				public InnerCamera (double x = 0, double y = 0);
			}
			[Compact]
			public class FluidCamera : Camera {
				public FluidCamera (double x = 0, double y = 0);
			}
			[Compact]
			public class SimpleCamera : Camera {
				public SimpleCamera (double x = 0, double y = 0);
			}
			public enum Kind {
				FluidCamera,
				InnerCamera,
				SimpleCamera
			}
			public delegate void CameraSetPosition (Point2d position);
			public int _retainCount;
			public Kind kind;
			public Vector2d position;
			public CameraSetPosition setPosition;
			public unowned Camera retain ();
			public void release ();
			public extern void free ();
			public Camera ();
		}
		[CCode (ref_function = "sdx_graphics_sprite_retain", unref_function = "sdx_graphics_sprite_release")]
		[Compact]
		public class Sprite {
			[Compact]
			public class AnimatedSprite : Sprite {
				public AnimatedSprite (string path, int width, int height);
				public void setFrame (int frame);
			}
			[Compact]
			public class TextureSprite : Sprite {
				public TextureSprite (string path);
			}
			[Compact]
			public class AtlasSprite : Sprite {
				public AtlasSprite (AtlasRegion region);
			}
			[Compact]
			public class CompositeSprite : Sprite {
				public CompositeSprite (string path, Compositor builder);
			}
			[Compact]
			public class TextSprite : Sprite {
				public TextSprite (string text, sdx.Font font, SDL.Video.Color color);
				public void setText (string text, sdx.Font font, SDL.Video.Color color);
			}
			public enum Kind {
				AnimatedSprite,
				TextureSprite,
				AtlasSprite,
				CompositeSprite,
				TextSprite
			}
			public int _retainCount;
			public static int uniqueId;
			public int id;
			public SDL.Video.Texture texture;
			public int width;
			public int height;
			public int x;
			public int y;
			public int index;
			public int frame;
			public Scale scale;
			public SDL.Video.Color color;
			public bool centered;
			public int layer;
			public string path;
			public Kind kind;
			public unowned Sprite retain ();
			public void release ();
			public extern void free ();
			public void render (int x, int y, SDL.Video.Rect? clip = null);
			public void copy (SDL.Video.Rect? src = null, SDL.Video.Rect? dest = null);
			public Sprite ();
		}
		[CCode (ref_function = "sdx_graphics_surface_retain", unref_function = "sdx_graphics_surface_release")]
		[Compact]
		public class Surface {
			[Compact]
			public class CachedSurface : Surface {
				public static sdx.graphics.Surface[] cache;
				public static void initialize (int size);
				public CachedSurface (sdx.files.FileHandle file);
				public static int indexOfPath (string path);
			}
			[Compact]
			public class TextureSurface : Surface {
				public TextureSurface (sdx.files.FileHandle file);
				public void setFilter (int minFilter, int magFilter);
				public void setWrap (int u, int v);
			}
			public int _retainCount;
			public static int uniqueId;
			public SDL.Video.Surface? surface;
			public int id;
			public string path;
			public unowned Surface retain ();
			public void release ();
			public extern void free ();
			public SDL.Video.Surface getSurface (string ext, SDL.RWops raw);
			public Surface ();
			public int width { get; }
			public int height { get; }
		}
		[CCode (ref_function = "sdx_graphics_texture_atlas_retain", unref_function = "sdx_graphics_texture_atlas_release")]
		[Compact]
		public class TextureAtlas {
			public int _retainCount;
			public Surface.TextureSurface? texture;
			public List<AtlasRegion> regions;
			public unowned TextureAtlas retain ();
			public void release ();
			public extern void free ();
			public TextureAtlas (FileHandle packFile, FileHandle? imageDir = null, bool flip = false);
			public AtlasRegion? findRegion (string name, int index = -1);
			public Sprite? createSprite (string name, int index = -1);
			public void load (TextureAtlasData data);
		}
		[CCode (ref_function = "sdx_graphics_atlas_region_retain", unref_function = "sdx_graphics_atlas_region_release")]
		[Compact]
		public class AtlasRegion {
			public int _retainCount;
			public TextureRegion rg;
			public int index;
			public string name;
			public int offsetX;
			public int offsetY;
			public int packedWidth;
			public int packedHeight;
			public int originalWidth;
			public int originalHeight;
			public bool rotate;
			public int[] splits;
			public int[] pads;
			public unowned AtlasRegion retain ();
			public void release ();
			public extern void free ();
			public AtlasRegion (Surface.TextureSurface texture, int x, int y, int width, int height);
			public void flip (bool x, bool y);
		}
		[CCode (ref_function = "sdx_graphics_page_retain", unref_function = "sdx_graphics_page_release")]
		[Compact]
		public class Page {
			public int _retainCount;
			public static int uniqueId;
			public int id;
			public FileHandle? textureFile;
			public Surface.TextureSurface? texture;
			public int height;
			public int width;
			public bool useMipMaps;
			public Format format;
			public int minFilter;
			public int magFilter;
			public int uWrap;
			public int vWrap;
			public unowned Page retain ();
			public void release ();
			public extern void free ();
			public Page (FileHandle handle, int width, int height, bool useMipMaps, Format format, int minFilter, int magFilter, int uWrap, int vWrap);
		}
		[CCode (ref_function = "sdx_graphics_region_retain", unref_function = "sdx_graphics_region_release")]
		[Compact]
		public class Region {
			public int _retainCount;
			public Page page;
			public int index;
			public string name;
			public int offsetX;
			public int offsetY;
			public int originalWidth;
			public int originalHeight;
			public bool rotate;
			public int left;
			public int top;
			public int width;
			public int height;
			public bool flip;
			public int[] splits;
			public int[] pads;
			public unowned Region retain ();
			public void release ();
			public extern void free ();
			public Region (Page page, int left, int top, int width, int height, string name, bool rotatate);
		}
		[CCode (ref_function = "sdx_graphics_texture_atlas_data_retain", unref_function = "sdx_graphics_texture_atlas_data_release")]
		[Compact]
		public class TextureAtlasData {
			public int _retainCount;
			public static string[] tuple;
			public List<Page> pages;
			public List<Region> regions;
			public unowned TextureAtlasData retain ();
			public void release ();
			public extern void free ();
			public static int readTuple (DataInputStream reader);
			public static string readValue (DataInputStream reader);
			public TextureAtlasData (FileHandle packFile, FileHandle imagesDir, bool flip);
		}
		[CCode (ref_function = "sdx_graphics_texture_region_retain", unref_function = "sdx_graphics_texture_region_release")]
		[Compact]
		public class TextureRegion {
			public int _retainCount;
			public Surface.TextureSurface? texture;
			public int top;
			public int left;
			public int width;
			public int height;
			public int regionWidth;
			public int regionHeight;
			public double u;
			public double v;
			public double u2;
			public double v2;
			public unowned TextureRegion retain ();
			public void release ();
			public extern void free ();
			public TextureRegion (Surface.TextureSurface texture, int x = 0, int y = 0, int width = 0, int height = 0);
			public void setRegion (double u, double v, double u2, double v2);
			public void setRegionXY (int x, int y, int width, int height);
			public void setByRegion (TextureRegion region);
			public void setByRegionXY (TextureRegion region, int x, int y, int width, int height);
			public void flip (bool x, bool y);
			public double getU ();
			public void setU (double u);
			public double getV ();
			public void setV (double v);
			public double getU2 ();
			public void setU2 (double u2);
			public double getV2 ();
			public void setV2 (double v2);
			public int getRegionX ();
			public void setRegionX (int x);
			public int getRegionY ();
			public void setRegionY (int y);
			public int getRegionWidth ();
			public void setRegionWidth (int width);
			public int getRegionHeight ();
			public void setRegionHeight (int height);
			public bool isFlipX ();
			public bool isFlipY ();
		}
		public struct Scale {
			public double x;
			public double y;
		}
		public enum TextureFilter {
			Nearest,
			Linear,
			MipMap,
			MipMapNearestNearest,
			MipMapLinearNearest,
			MipMapNearestLinear,
			MipMapLinearLinear;
			public static TextureFilter from (string value);
			public bool isMipMap ();
			public string to_string ();
		}
		public enum TextureWrap {
			ClampToEdge = 1,
			Repeat = 2;
			public static TextureWrap from (string value);
			public string to_string ();
		}
		public enum Format {
			Alpha,
			Intensity,
			LuminanceAlpha,
			RGB565,
			RGBA4444,
			RGB888,
			RGBA8888;
			public static Format from (string value);
			public string to_string ();
		}
	}
	namespace utils {
		[CCode (ref_function = "sdx_utils_cache_retain", unref_function = "sdx_utils_cache_release")]
		[Compact]
		public class Cache<T> {
			public int _retainCount;
			public T[] items;
			public int size;
			public unowned Cache<T> retain ();
			public void release ();
			public extern void free ();
			public Cache (int capacity = 4);
			public bool isEmpty ();
			public T @get (int index);
			public void put (int index, T entity);
			public void enque (T entity);
			public T deque ();
			public void grow (int newSize);
		}
		[CCode (ref_function = "sdx_utils_file_retain", unref_function = "sdx_utils_file_release")]
		[Compact]
		public class File {
			public int _retainCount;
			public SDL.RWops file;
			public string path;
			public string[] files;
			public unowned File retain ();
			public void release ();
			public extern void free ();
			public File (string path);
			public string getPath ();
			public string getName ();
			public string getParent ();
			public bool exists ();
			public bool isFile ();
			public bool isDirectory ();
			public int length ();
			public string read ();
			public string[] list ();
		}
		[CCode (ref_function = "sdx_utils_json_retain", unref_function = "sdx_utils_json_release")]
		[Compact]
		public class Json {
			public int _retainCount;
			public static string gap;
			public static string indent;
			public int at;
			public char ch;
			public string text;
			public JsDelegate replacer;
			public const string HEX_DIGIT = "0123456789abcdef";
			public const string escape0 = "\"\\/bfnrt";
			public const string[] escape1 = { "\"", "\\", "/", "\b", "\f", "\n", "\r", "\t" };
			public unowned Json retain ();
			public void release ();
			public extern void free ();
			public Json (JsDelegate replacer = null);
			public static JsVariant parse (string source);
			public static string stringify (JsVariant value, JsDelegate replacer = null, string space = "");
			public string quote (string str);
			public JsVariant getItem (JsVariant holder, string key);
			public string str (string key, JsVariant holder);
			public JsVariant parseJson (string source);
			public char next (char? c = null);
			public JsVariant getValue ();
			public JsVariant getNumber ();
			public JsVariant getString ();
			public void skipWhite ();
			public JsVariant getWord ();
			public JsVariant getArray ();
			public JsVariant getObject ();
		}
		[CCode (ref_function = "sdx_utils_js_variant_retain", unref_function = "sdx_utils_js_variant_release")]
		[Compact]
		public class JsVariant {
			public int _retainCount;
			public bool boolean;
			public double number;
			public string string;
			public HashTable<string,JsVariant> object;
			public List<JsVariant> array;
			public JsType type;
			public unowned JsVariant retain ();
			public void release ();
			public extern void free ();
			public static JsVariant String (string value);
			public static JsVariant Number (double value);
			public static JsVariant Boolean (bool value);
			public JsVariant (JsType type, bool isNull = false);
			public JsVariant at (int index);
			public JsVariant member (string key);
		}
		[CCode (ref_function = "sdx_utils_string_tokenizer_retain", unref_function = "sdx_utils_string_tokenizer_release")]
		[Compact]
		public class StringTokenizer {
			public int _retainCount;
			public int currentPosition;
			public int newPosition;
			public int maxPosition;
			public string str;
			public string delimiters;
			public bool retDelims;
			public bool delimsChanged;
			public int maxDelimCodePoint;
			public int[] delimiterCodePoints;
			public unowned StringTokenizer retain ();
			public void release ();
			public extern void free ();
			public StringTokenizer (string str, string delim = " \t\n\r\f", bool returnDelims = false);
			public void setMaxDelimCodePoint ();
			public int skipDelimiters (int startPos);
			public int scanToken (int startPos);
			public bool isDelimiter (char c);
			public bool hasMoreTokens ();
			public string nextToken (string delim = "");
			public int countTokens ();
		}
		public enum JsType {
			JS_INVALID,
			JS_BOOLEAN,
			JS_NUMBER,
			JS_STRING,
			JS_OBJECT,
			JS_ARRAY
		}
		public errordomain JsonException {
			SyntaxError,
			UnexpectedCharacter,
			InvalidString,
			InvalidArray,
			InvalidObject,
			DuplicateKey
		}
		public delegate JsVariant JsDelegate (JsVariant holder, string key, JsVariant value);
		public const string pathSeparator = "/";
		public const char pathSeparatorChar = '/';
	}
	namespace Color {
		public const SDL.Video.Color LiteSlateBlue = { 0x6e, 0x84, 0xae, 0xff };
		public const SDL.Video.Color AliceBlue = { 0xf0, 0xf8, 0xff, 0xff };
		public const SDL.Video.Color AntiqueWhite = { 0xfa, 0xeb, 0xd7, 0xff };
		public const SDL.Video.Color Aqua = { 0x00, 0xFF, 0x00, 0xFF };
		public const SDL.Video.Color Aquamarine = { 0x7F, 0xff, 0xd4, 0xff };
		public const SDL.Video.Color Azure = { 0xF0, 0xFF, 0xFf, 0xFF };
		public const SDL.Video.Color Beige = { 0xf5, 0xf5, 0xdc, 0xff };
		public const SDL.Video.Color Bisque = { 0xff, 0xe4, 0xc4, 0xff };
		public const SDL.Video.Color Black = { 0x00, 0x00, 0x00, 0x00 };
		public const SDL.Video.Color BlanchedAlmond = { 0xff, 0xeb, 0xcd, 0xff };
		public const SDL.Video.Color Blue = { 0x00, 0x00, 0xff, 0xff };
		public const SDL.Video.Color BlueViolet = { 0x8a, 0x2b, 0xe2, 0xff };
		public const SDL.Video.Color Brown = { 0xa5, 0x2a, 0x2a, 0xff };
		public const SDL.Video.Color BurlyWood = { 0xde, 0xb8, 0x87, 0xff };
		public const SDL.Video.Color CadetBlue = { 0x5f, 0x9e, 0xa0, 0xff };
		public const SDL.Video.Color Chartreuse = { 0x7f, 0xff, 0x00, 0xff };
		public const SDL.Video.Color Chocolate = { 0xd2, 0x69, 0x1e, 0xff };
		public const SDL.Video.Color Coral = { 0xff, 0x7f, 0x50, 0xff };
		public const SDL.Video.Color CornflowerBlue = { 0x64, 0x95, 0xed, 0xff };
		public const SDL.Video.Color Cornsilk = { 0xff, 0xf8, 0xdc, 0xff };
		public const SDL.Video.Color Crimson = { 0xdc, 0x14, 0x3c, 0xff };
		public const SDL.Video.Color Cyan = { 0x00, 0xff, 0xff, 0xff };
		public const SDL.Video.Color DarkBlue = { 0x00, 0x00, 0x8b, 0xff };
		public const SDL.Video.Color DarkCyan = { 0x00, 0x8b, 0x8b, 0xff };
		public const SDL.Video.Color DarkGoldenrod = { 0xb8, 0x86, 0x0b, 0xff };
		public const SDL.Video.Color DarkGray = { 0xa9, 0xa9, 0xa9, 0xff };
		public const SDL.Video.Color DarkGreen = { 0x00, 0x64, 0x00, 0xff };
		public const SDL.Video.Color DarkKhaki = { 0xbd, 0xb7, 0x6b, 0xff };
		public const SDL.Video.Color DarkMagenta = { 0x8b, 0x00, 0x8b, 0xff };
		public const SDL.Video.Color DarkOliveGreen = { 0x55, 0x6b, 0x2f, 0xff };
		public const SDL.Video.Color DarkOrange = { 0xff, 0x8c, 0x00, 0xff };
		public const SDL.Video.Color DarkOrchid = { 0x99, 0x32, 0xcc, 0xff };
		public const SDL.Video.Color DarkRed = { 0x8b, 0x00, 0x00, 0xff };
		public const SDL.Video.Color DarkSalmon = { 0xe9, 0x96, 0x7a, 0xff };
		public const SDL.Video.Color DarkSeaGreen = { 0x8f, 0xbc, 0x8b, 0xff };
		public const SDL.Video.Color DarkSlateBlue = { 0x48, 0x3d, 0x8b, 0xff };
		public const SDL.Video.Color DarkSlateGray = { 0x2f, 0x4f, 0x4f, 0xff };
		public const SDL.Video.Color DarkTurquoise = { 0x00, 0xce, 0xd1, 0xff };
		public const SDL.Video.Color DarkViolet = { 0x94, 0x00, 0xd3, 0xff };
		public const SDL.Video.Color DeepPink = { 0xff, 0x14, 0x93, 0xff };
		public const SDL.Video.Color DeepSkyBlue = { 0x00, 0xbf, 0xff, 0xff };
		public const SDL.Video.Color DimGray = { 0x69, 0x69, 0x69, 0xff };
		public const SDL.Video.Color DodgerBlue = { 0x1e, 0x90, 0xff, 0xff };
		public const SDL.Video.Color Firebrick = { 0xb2, 0x22, 0x22, 0xff };
		public const SDL.Video.Color FloralWhite = { 0xff, 0xfa, 0xf0, 0xff };
		public const SDL.Video.Color ForestGreen = { 0x22, 0x8b, 0x22, 0xff };
		public const SDL.Video.Color Fuchsia = { 0xff, 0x00, 0xff, 0xff };
		public const SDL.Video.Color Gainsboro = { 0xdc, 0xdc, 0xdc, 0xff };
		public const SDL.Video.Color GhostWhite = { 0xf8, 0xf8, 0xff, 0xff };
		public const SDL.Video.Color Gold = { 0xff, 0xd7, 0x00, 0xff };
		public const SDL.Video.Color Goldenrod = { 0xda, 0xa5, 0x20, 0xff };
		public const SDL.Video.Color Gray = { 0x80, 0x80, 0x80, 0xff };
		public const SDL.Video.Color Green = { 0x00, 0x80, 0x00, 0xff };
		public const SDL.Video.Color GreenYellow = { 0xad, 0xff, 0x2f, 0xff };
		public const SDL.Video.Color Honeydew = { 0xf0, 0xff, 0xf0, 0xff };
		public const SDL.Video.Color HotPink = { 0xff, 0x69, 0xb4, 0xff };
		public const SDL.Video.Color IndianRed = { 0xcd, 0x5c, 0x5c, 0xff };
		public const SDL.Video.Color Indigo = { 0x4b, 0x00, 0x82, 0xff };
		public const SDL.Video.Color Ivory = { 0xff, 0xff, 0xf0, 0xff };
		public const SDL.Video.Color Khaki = { 0xf0, 0xe6, 0x8c, 0xff };
		public const SDL.Video.Color Lavender = { 0xe6, 0xe6, 0xfa, 0xff };
		public const SDL.Video.Color LavenderBlush = { 0xff, 0xf0, 0xf5, 0xff };
		public const SDL.Video.Color LawnGreen = { 0x7c, 0xfc, 0x00, 0xff };
		public const SDL.Video.Color LemonChiffon = { 0xff, 0xfa, 0xcd, 0xff };
		public const SDL.Video.Color LightBlue = { 0xad, 0xd8, 0xe6, 0xff };
		public const SDL.Video.Color LightCoral = { 0xf0, 0x80, 0x80, 0xff };
		public const SDL.Video.Color LightCyan = { 0xe0, 0xff, 0xff, 0xff };
		public const SDL.Video.Color LightGoldenrodYellow = { 0xfa, 0xfa, 0xd2, 0xff };
		public const SDL.Video.Color LightGray = { 0xd3, 0xd3, 0xd3, 0xff };
		public const SDL.Video.Color LightGreen = { 0x90, 0xee, 0x90, 0xff };
		public const SDL.Video.Color LightPink = { 0xff, 0xb6, 0xc1, 0xff };
		public const SDL.Video.Color LightSalmon = { 0xff, 0xa0, 0x7a, 0xff };
		public const SDL.Video.Color LightSeaGreen = { 0x20, 0xb2, 0xaa, 0xff };
		public const SDL.Video.Color LightSkyBlue = { 0x87, 0xce, 0xfa, 0xff };
		public const SDL.Video.Color LightSlateGray = { 0x77, 0x88, 0x99, 0xff };
		public const SDL.Video.Color LightSteelBlue = { 0xb0, 0xc4, 0xde, 0xff };
		public const SDL.Video.Color LightYellow = { 0xff, 0xff, 0xe0, 0xff };
		public const SDL.Video.Color Lime = { 0x00, 0xff, 0x00, 0xff };
		public const SDL.Video.Color LimeGreen = { 0x32, 0xcd, 0x32, 0xff };
		public const SDL.Video.Color Linen = { 0xfa, 0xf0, 0xe6, 0xff };
		public const SDL.Video.Color Magenta = { 0xff, 0x00, 0xff, 0xff };
		public const SDL.Video.Color Maroon = { 0x80, 0x00, 0x00, 0xff };
		public const SDL.Video.Color MediumAquamarine = { 0x66, 0xcd, 0xaa, 0xff };
		public const SDL.Video.Color MediumBlue = { 0x00, 0x00, 0xcd, 0xff };
		public const SDL.Video.Color MediumOrchid = { 0xba, 0x55, 0xd3, 0xff };
		public const SDL.Video.Color MediumPurple = { 0x93, 0x70, 0xdb, 0xff };
		public const SDL.Video.Color MediumSeaGreen = { 0x3c, 0xb3, 0x71, 0xff };
		public const SDL.Video.Color MediumSlateBlue = { 0x7b, 0x68, 0xee, 0xff };
		public const SDL.Video.Color MediumSpringGreen = { 0x00, 0xfa, 0x9a, 0xff };
		public const SDL.Video.Color MediumTurquoise = { 0x48, 0xd1, 0xcc, 0xff };
		public const SDL.Video.Color MediumVioletRed = { 0xc7, 0x15, 0x85, 0xff };
		public const SDL.Video.Color MidnightBlue = { 0x19, 0x19, 0x70, 0xff };
		public const SDL.Video.Color MintCream = { 0xf5, 0xff, 0xfa, 0xff };
		public const SDL.Video.Color MistyRose = { 0xff, 0xe4, 0xe1, 0xff };
		public const SDL.Video.Color Moccasin = { 0xff, 0xe4, 0xb5, 0xff };
		public const SDL.Video.Color NavajoWhite = { 0xff, 0xde, 0xad, 0xff };
		public const SDL.Video.Color Navy = { 0x00, 0x00, 0x80, 0xff };
		public const SDL.Video.Color OldLace = { 0xfd, 0xf5, 0xe6, 0xff };
		public const SDL.Video.Color Olive = { 0x80, 0x80, 0x00, 0xff };
		public const SDL.Video.Color OliveDrab = { 0x6b, 0x8e, 0x23, 0xff };
		public const SDL.Video.Color Orange = { 0xff, 0xa5, 0x00, 0xff };
		public const SDL.Video.Color OrangeRed = { 0xff, 0x45, 0x00, 0xff };
		public const SDL.Video.Color Orchid = { 0xda, 0x70, 0xd6, 0xff };
		public const SDL.Video.Color PaleGoldenrod = { 0xee, 0xe8, 0xaa, 0xff };
		public const SDL.Video.Color PaleGreen = { 0x98, 0xfb, 0x98, 0xff };
		public const SDL.Video.Color PaleTurquoise = { 0xaf, 0xee, 0xee, 0xff };
		public const SDL.Video.Color PaleVioletRed = { 0xdb, 0x70, 0x93, 0xff };
		public const SDL.Video.Color PapayaWhip = { 0xff, 0xef, 0xd5, 0xff };
		public const SDL.Video.Color PeachPuff = { 0xff, 0xda, 0xb9, 0xff };
		public const SDL.Video.Color Peru = { 0xcd, 0x85, 0x3f, 0xff };
		public const SDL.Video.Color Pink = { 0xff, 0xc0, 0xcb, 0xff };
		public const SDL.Video.Color Plum = { 0xdd, 0xa0, 0xdd, 0xff };
		public const SDL.Video.Color PowderBlue = { 0xb0, 0xe0, 0xe6, 0xff };
		public const SDL.Video.Color Purple = { 0x80, 0x00, 0x80, 0xff };
		public const SDL.Video.Color Red = { 0xff, 0x00, 0x00, 0xff };
		public const SDL.Video.Color RosyBrown = { 0xbc, 0x8f, 0x8f, 0xff };
		public const SDL.Video.Color RoyalBlue = { 0x41, 0x69, 0xe1, 0xff };
		public const SDL.Video.Color SaddleBrown = { 0x8b, 0x45, 0x13, 0xff };
		public const SDL.Video.Color Salmon = { 0xfa, 0x80, 0x72, 0xff };
		public const SDL.Video.Color SandyBrown = { 0xf4, 0xa4, 0x60, 0xff };
		public const SDL.Video.Color SeaGreen = { 0x2e, 0x8b, 0x57, 0xff };
		public const SDL.Video.Color SeaShell = { 0xff, 0xf5, 0xee, 0xff };
		public const SDL.Video.Color Sienna = { 0xa0, 0x52, 0x2d, 0xff };
		public const SDL.Video.Color Silver = { 0xc0, 0xc0, 0xc0, 0xff };
		public const SDL.Video.Color SkyBlue = { 0x87, 0xce, 0xeb, 0xff };
		public const SDL.Video.Color SlateBlue = { 0x6a, 0x5a, 0xcd, 0xff };
		public const SDL.Video.Color SlateGray = { 0x70, 0x80, 0x90, 0xff };
		public const SDL.Video.Color Snow = { 0xff, 0xfa, 0xfa, 0xff };
		public const SDL.Video.Color SpringGreen = { 0x00, 0xff, 0x7f, 0xff };
		public const SDL.Video.Color SteelBlue = { 0x46, 0x82, 0xb4, 0xff };
		public const SDL.Video.Color Tan = { 0xd2, 0xb4, 0x8c, 0xff };
		public const SDL.Video.Color Teal = { 0x00, 0x80, 0x80, 0xff };
		public const SDL.Video.Color Thistle = { 0xd8, 0xbf, 0xd8, 0xff };
		public const SDL.Video.Color Tomato = { 0xff, 0x63, 0x47, 0xff };
		public const SDL.Video.Color Turquoise = { 0x40, 0xe0, 0xd0, 0xff };
		public const SDL.Video.Color Violet = { 0xee, 0x82, 0xee, 0xff };
		public const SDL.Video.Color Wheat = { 0xf5, 0xde, 0xb3, 0xff };
		public const SDL.Video.Color White = { 0xff, 0xff, 0xff, 0xff };
		public const SDL.Video.Color WhiteSmoke = { 0xf5, 0xf5, 0xf5, 0xff };
		public const SDL.Video.Color Yellow = { 0xff, 0xff, 0x00, 0xff };
		public const SDL.Video.Color YellowGreen = { 0x9a, 0xcd, 0x32, 0xff };
	}
	[CCode (ref_function = "sdx_data_input_stream_retain", unref_function = "sdx_data_input_stream_release")]
	[Compact]
	public class DataInputStream {
		public int _retainCount;
		public string[] data;
		public int ctr;
		public unowned DataInputStream retain ();
		public void release ();
		public extern void free ();
		public DataInputStream (string data);
		public string? read_line ();
	}
	[CCode (ref_function = "sdx_font_retain", unref_function = "sdx_font_release")]
	[Compact]
	public class Font {
		public int _retainCount;
		public static int uniqueId;
		public int id;
		public string path;
		public int size;
		public SDLTTF.Font innerFont;
		public SDL.RWops raw;
		public unowned Font retain ();
		public void release ();
		public extern void free ();
		public Font (string path, int size);
		public SDL.Video.Surface render (string text, SDL.Video.Color color);
	}
	public struct Blit {
		public SDL.Video.Rect source;
		public SDL.Video.Rect dest;
		public SDL.Video.RendererFlip flip;
	}
	public enum FileType {
		Resource = 1,
		Asset,
		Absolute,
		Relative
	}
	public enum Direction {
		NONE,
		LEFT,
		RIGHT,
		UP,
		DOWN
	}
	public errordomain IOException {
		InvalidData
	}
	public errordomain SdlException {
		Initialization,
		ImageInitialization,
		TtfInitialization,
		TextureFilteringNotEnabled,
		OpenWindow,
		CreateRenderer,
		InvalidForPlatform,
		UnableToLoadResource,
		UnableToLoadSurface,
		UnableToLoadTexture,
		NullPointer,
		NoSuchElement,
		IllegalStateException,
		RuntimeException,
		NotReached
	}
	public delegate Blit[] Compositor (int x, int y);
	internal static FileType platform;
	internal static Renderer renderer;
	internal static sdx.Font font;
	internal static sdx.Font smallFont;
	internal static sdx.Font largeFont;
	internal static SDL.Video.Display display;
	internal static SDL.Video.DisplayMode displayMode;
	internal static SDL.Video.Color fpsColor;
	internal static SDL.Video.Color bgdColor;
	internal static sdx.graphics.Sprite.TextSprite fpsSprite;
	internal static sdx.graphics.Sprite.AnimatedSprite fps1;
	internal static sdx.graphics.Sprite.AnimatedSprite fps2;
	internal static sdx.graphics.Sprite.AnimatedSprite fps3;
	internal static sdx.graphics.Sprite.AnimatedSprite fps4;
	internal static sdx.graphics.Sprite.AnimatedSprite fps5;
	internal static long pixelFactor;
	internal static bool showFps;
	internal static double fps;
	internal static double delta;
	internal static double mouseX;
	internal static double mouseY;
	internal static bool mouseDown;
	internal static bool running;
	internal static uint8[] keys;
	internal static bool[] direction;
	internal static string resourceBase;
	internal static int _frames;
	internal static Event _evt;
	internal static double _elapsed;
	internal static double _freq;
	internal static double _mark1;
	internal static double _mark2;
	internal static int width;
	internal static int height;
	internal static Window initialize (int width, int height, string name);
	internal static double getRandom ();
	internal static void setResourceBase (string path);
	internal static void setDefaultFont (string path, int size);
	internal static void setSmallFont (string path, int size);
	internal static void setLargeFont (string path, int size);
	internal static void setShowFps (bool value);
	internal static void drawFps ();
	internal static double getNow ();
	internal static void start ();
	internal static void update ();
	internal static void processEvents ();
	internal static void begin ();
	internal static void end ();
	internal static void log (string text);
}
namespace systems {
	[Compact]
	public class LogicSystem : System {
		public LogicSystem (Game game);
	}
	[Compact]
	public class PhysicsSystem : System {
		public PhysicsSystem (Game game);
	}
	[CCode (ref_function = "systems_system_retain", unref_function = "systems_system_release")]
	[Compact]
	public class System {
		public int _retainCount;
		public SystemInitialize initialize;
		public SystemExecute execute;
		public unowned System retain ();
		public void release ();
		public extern void free ();
		public System ();
		public ISystem _ISystem { get; }
	}
	[Immutable]
	[SimpleType]
	public struct ISystem {
		public weak SystemInitialize initialize;
		public weak SystemExecute execute;
	}
	public delegate void SystemInitialize ();
	public delegate void SystemExecute (ref Entity* player, int tick);
}
public enum Collision {
	X,
	Y,
	CORNER
}
public enum Actor {
	DEFAULT,
	BACKGROUND,
	TEXT,
	PLAYER,
	BONUS,
	HUD
}
public enum Category {
	BACKGROUND,
	PLAYER,
	BONUS
}
public errordomain Exception {
	SDLException,
	InvalidValue,
	MapFileFormat
}
[CCode (ref_function = "entities_retain", unref_function = "entities_release")]
[Compact]
public class Entities {
	public int retainCount__;
	public static int uniqueId;
	public unowned Entities retain ();
	public void release ();
	public extern void free ();
	public Entities ();
	public Entity createPlayer ();
	public Entity createBerry ();
	public Blit[] composePlayer (int x, int y);
}
[CCode (ref_function = "game_retain", unref_function = "game_release")]
[Compact]
public class Game {
	public int retainCount__;
	public Map map;
	public Camera.InnerCamera camera;
	public Entities factory;
	public Hud hud;
	public Entity* player;
	public bool touch;
	public List<weak Entity*> sprites;
	public Entity[] pool;
	public systems.System[] sys;
	public cp.Space space;
	public cp.Body body;
	public cp.CircleShape shape;
	public weak cp.Body groundBody;
	public cp.SegmentShape groundShape;
	public unowned Game retain ();
	public void release ();
	public extern void free ();
	public Game ();
	public void update (int tick);
	public void render (int tick);
	public void mapInput ();
}
[CCode (ref_function = "hud_retain", unref_function = "hud_release")]
[Compact]
public class Hud {
	public int retainCount__;
	public string text1;
	public string text2;
	public string text3;
	public sdx.graphics.Sprite.TextSprite hudText1;
	public sdx.graphics.Sprite.TextSprite hudText2;
	public sdx.graphics.Sprite.TextSprite hudText3;
	public unowned Hud retain ();
	public void release ();
	public extern void free ();
	public Hud ();
	public void render (ref Entity* player, int tick);
}
[CCode (ref_function = "map_retain", unref_function = "map_release")]
[Compact]
public class Map {
	public int retainCount__;
	public int width;
	public int height;
	public int tileheight;
	public int tilewidth;
	public string tileset;
	public uint8[] tiles;
	public sdx.graphics.Sprite sprite;
	public const int AIR = 0;
	public const int START = 79;
	public const int FINISH = 111;
	public const int TILES_PER_ROW = 16;
	public unowned Map retain ();
	public void release ();
	public extern void free ();
	public Map (string mapPath);
	public int getTile (double x, double y);
	public bool isSolid (double x, double y);
	public bool isOnGround (Point2d pos, Vector2d size);
	public bool isHit (Point2d pos, Vector2d size);
	public void moveBox (ref Point2d pos, ref Vector2d vel, Vector2d size);
	public void render (sdx.graphics.Camera camera);
}
public struct Entity {
	public int id;
	public string name;
	public bool active;
	public Category category;
	public Actor actor;
	public Point2d position;
	public Rect bounds;
	public sdx.graphics.Sprite sprite;
	public Vector2d? size;
	public Vector2d? scale;
	public Color? tint;
	public Timer? expires;
	public Health? health;
	public Vector2d? velocity;
}
public struct Blit {
	public SDL.Video.Rect source;
	public SDL.Video.Rect dest;
	public SDL.Video.RendererFlip flip;
}
public struct Timer {
	public int begin;
	public int finish;
	public int best;
}
public struct ScaleTween {
	public double min;
	public double max;
	public double speed;
	public bool repeat;
	public bool active;
}
public struct Sprite {
	public weak Texture texture;
	public int width;
	public int height;
}
public struct Point2d {
	public double x;
	public double y;
	public Point2d add (Vector2d v);
	public Point2d sub (Vector2d v);
}
public struct Vector2d {
	public double x;
	public double y;
	public Vector2d mul (double f);
	public Vector2d div (double f);
	public double len ();
}
public struct Health {
	public int curHealth;
	public int maxHealth;
}
public delegate Blit[] Compositor (int x, int y);
public const Point2d WINDOW_SIZE = { 1280, 720 };
public static double startTime;
public static int lastTick;
public static double clamp (double value, double low, double hi);
public static Blit blit (SDL.Video.Rect source, SDL.Video.Rect dest, SDL.Video.RendererFlip flip);
public static Timer timer (int begin = -1, int finish = -1, int best = -1);
public static ScaleTween scaletween (double min, double max, double speed, bool repeat, bool active);
public static Sprite sprite (Texture texture, int width, int height);
public static Point2d point2d (double x = 0, double y = 0);
public static Vector2d vector2d (double x = 0, double y = 0);
public static Health health (int curHealth, int maxHealth);
public static Rect rect (int x, int y, int h, int w);
public static Color color (uint8 r = 0, uint8 g = 0, uint8 b = 0, uint8 a = 255);
public static string formatTime (int ticks);
public static void sdlFailIf (bool cond, string reason);
public static void main (string[] args);
