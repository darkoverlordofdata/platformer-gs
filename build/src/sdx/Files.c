/* Files.c generated by valac 0.34.8, the Vala compiler
 * generated from Files.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define SDX_TYPE_FILE_TYPE (sdx_file_type_get_type ())
typedef struct _sdxDataInputStream sdxDataInputStream;

typedef enum  {
	SDX_FILE_TYPE_Resource = 1,
	SDX_FILE_TYPE_Asset,
	SDX_FILE_TYPE_Absolute,
	SDX_FILE_TYPE_Relative
} sdxFileType;

struct _sdxDataInputStream {
	gint _retainCount;
	gchar** data;
	gint data_length1;
	gint ctr;
};



GType sdx_file_type_get_type (void) G_GNUC_CONST;
void sdx_data_input_stream_free (sdxDataInputStream* self);
static void sdx_data_input_stream_instance_init (sdxDataInputStream * self);
sdxDataInputStream* sdx_data_input_stream_retain (sdxDataInputStream* self);
void sdx_data_input_stream_release (sdxDataInputStream* self);
void sdx_data_input_stream_free (sdxDataInputStream* self);
sdxDataInputStream* sdx_data_input_stream_new (const gchar* data);
gchar* sdx_data_input_stream_read_line (sdxDataInputStream* self);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GType sdx_file_type_get_type (void) {
	static volatile gsize sdx_file_type_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_file_type_type_id__volatile)) {
		static const GEnumValue values[] = {{SDX_FILE_TYPE_Resource, "SDX_FILE_TYPE_Resource", "resource"}, {SDX_FILE_TYPE_Asset, "SDX_FILE_TYPE_Asset", "asset"}, {SDX_FILE_TYPE_Absolute, "SDX_FILE_TYPE_Absolute", "absolute"}, {SDX_FILE_TYPE_Relative, "SDX_FILE_TYPE_Relative", "relative"}, {0, NULL, NULL}};
		GType sdx_file_type_type_id;
		sdx_file_type_type_id = g_enum_register_static ("sdxFileType", values);
		g_once_init_leave (&sdx_file_type_type_id__volatile, sdx_file_type_type_id);
	}
	return sdx_file_type_type_id__volatile;
}


sdxDataInputStream* sdx_data_input_stream_retain (sdxDataInputStream* self) {
	sdxDataInputStream* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->_retainCount), 1);
	result = self;
	return result;
}


void sdx_data_input_stream_release (sdxDataInputStream* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->_retainCount));
	if (_tmp0_) {
		sdx_data_input_stream_free (self);
	}
}


sdxDataInputStream* sdx_data_input_stream_new (const gchar* data) {
	sdxDataInputStream* self;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	g_return_val_if_fail (data != NULL, NULL);
	self = g_slice_new0 (sdxDataInputStream);
	sdx_data_input_stream_instance_init (self);
	_tmp0_ = data;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "\n", 0);
	self->data = (_vala_array_free (self->data, self->data_length1, (GDestroyNotify) g_free), NULL);
	self->data = _tmp2_;
	self->data_length1 = _vala_array_length (_tmp1_);
	self->ctr = 0;
	return self;
}


gchar* sdx_data_input_stream_read_line (sdxDataInputStream* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gchar** _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = self->ctr;
	_tmp2_ = self->data;
	_tmp2__length1 = self->data_length1;
	if (_tmp1_ < _tmp2__length1) {
		gchar** _tmp3_ = NULL;
		gint _tmp3__length1 = 0;
		gint _tmp4_ = 0;
		const gchar* _tmp5_ = NULL;
		_tmp3_ = self->data;
		_tmp3__length1 = self->data_length1;
		_tmp4_ = self->ctr;
		self->ctr = _tmp4_ + 1;
		_tmp5_ = _tmp3_[_tmp4_];
		_tmp0_ = _tmp5_;
	} else {
		_tmp0_ = NULL;
	}
	_tmp6_ = g_strdup (_tmp0_);
	result = _tmp6_;
	return result;
}


static void sdx_data_input_stream_instance_init (sdxDataInputStream * self) {
	self->_retainCount = 1;
}


void sdx_data_input_stream_free (sdxDataInputStream* self) {
	self->data = (_vala_array_free (self->data, self->data_length1, (GDestroyNotify) g_free), NULL);
	g_slice_free (sdxDataInputStream, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



