/* Systems.c generated by valac 0.34.8, the Vala compiler
 * generated from Systems.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_pixels.h>

typedef struct _Systems Systems;
typedef struct _Game Game;
void game_release (Game* self);
void game_free (Game* self);
Game* game_retain (Game* self);
#define _game_release0(var) ((var == NULL) ? NULL : (var = (game_release (var), NULL)))

#define TYPE_ENTITY (entity_get_type ())

#define TYPE_CATEGORY (category_get_type ())

#define TYPE_ACTOR (actor_get_type ())

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;
typedef struct _sdxgraphicsSprite sdxgraphicsSprite;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_TIMER (timer_get_type ())
typedef struct _Timer Timer;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;
typedef struct _Entity Entity;
#define _vector2d_free0(var) ((var == NULL) ? NULL : (var = (vector2d_free (var), NULL)))
#define _timer_free0(var) ((var == NULL) ? NULL : (var = (timer_free (var), NULL)))
typedef struct _Map Map;

#define TYPE_CAMERA (camera_get_type ())
typedef Vector2d Camera;

#define TYPE_CAMERA_TYPE (camera_type_get_type ())
typedef struct _Entities Entities;
typedef struct _Hud Hud;

#define SDX_TYPE_DIRECTION (sdx_direction_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))

struct _Systems {
	gint retainCount__;
	Game* game;
};

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_PLAYER,
	CATEGORY_BONUS
} Category;

typedef enum  {
	ACTOR_DEFAULT,
	ACTOR_BACKGROUND,
	ACTOR_TEXT,
	ACTOR_PLAYER,
	ACTOR_BONUS,
	ACTOR_HUD
} Actor;

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

struct _Timer {
	gint begin;
	gint finish;
	gint best;
};

struct _Health {
	gint curHealth;
	gint maxHealth;
};

struct _Entity {
	gint id;
	gchar* name;
	gboolean active;
	Category category;
	Actor actor;
	Point2d position;
	SDL_Rect bounds;
	sdxgraphicsSprite* sprite;
	Vector2d* size;
	Vector2d* scale;
	SDL_Color* tint;
	Timer* expires;
	Health* health;
	Vector2d* velocity;
};

typedef enum  {
	CAMERA_TYPE_FLUID_CAMERA,
	CAMERA_TYPE_INNER_CAMERA,
	CAMERA_TYPE_SIMPLE_CAMERA
} CameraType;

struct _Game {
	gint retainCount__;
	Map* map;
	Camera camera;
	CameraType cameraType;
	Entities* factory;
	Entity* entities;
	gint entities_length1;
	Systems* system;
	Hud* hud;
	Entity* player;
	GList* sprites;
};

typedef enum  {
	SDX_DIRECTION_NONE,
	SDX_DIRECTION_LEFT,
	SDX_DIRECTION_RIGHT,
	SDX_DIRECTION_UP,
	SDX_DIRECTION_DOWN
} sdxDirection;


extern guint8* sdx_keys;
extern gint sdx_keys_length1;
extern gboolean* sdx_dir;
extern gint sdx_dir_length1;

void systems_free (Systems* self);
void game_free (Game* self);
static void systems_instance_init (Systems * self);
Systems* systems_retain (Systems* self);
void systems_release (Systems* self);
void systems_free (Systems* self);
Systems* systems_new (Game* game);
GType entity_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
void sdx_graphics_sprite_free (sdxgraphicsSprite* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
GType timer_get_type (void) G_GNUC_CONST;
Timer* timer_dup (const Timer* self);
void timer_free (Timer* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
void systems_physics (Systems* self, Entity** player, gint tick);
void map_free (Map* self);
GType camera_get_type (void) G_GNUC_CONST;
Camera* camera_dup (const Camera* self);
void camera_free (Camera* self);
GType camera_type_get_type (void) G_GNUC_CONST;
void entities_free (Entities* self);
void hud_free (Hud* self);
gboolean map_onGround (Map* self, Point2d* pos, Vector2d* size);
GType sdx_direction_get_type (void) G_GNUC_CONST;
gdouble clamp (gdouble value, gdouble low, gdouble hi);
void map_moveBox (Map* self, Point2d* pos, Vector2d* vel, Vector2d* size);
void systems_camera (Systems* self, Entity** player, gint tick);
void camera_scrollBy (Camera *self, gdouble x);
void camera_scrollTo (Camera *self, gdouble x);
void systems_logic (Systems* self, Entity** player, gint tick);
gint map_getTile (Map* self, gdouble x, gdouble y);
#define MAP_START 79
#define MAP_FINISH 111
gchar* formatTime (gint ticks);

extern const SDL_Point WINDOW_SIZE;

Systems* systems_retain (Systems* self) {
	Systems* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->retainCount__), 1);
	result = self;
	return result;
}


void systems_release (Systems* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->retainCount__));
	if (_tmp0_) {
		systems_free (self);
	}
}


static gpointer _game_retain0 (gpointer self) {
	return self ? game_retain (self) : NULL;
}


Systems* systems_new (Game* game) {
	Systems* self;
	Game* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	g_return_val_if_fail (game != NULL, NULL);
	self = g_slice_new0 (Systems);
	systems_instance_init (self);
	_tmp0_ = game;
	_tmp1_ = _game_retain0 (_tmp0_);
	_game_release0 (self->game);
	self->game = _tmp1_;
	return self;
}


/**
 *  Physics
 */
static gpointer _vector2d_dup0 (gpointer self) {
	return self ? vector2d_dup (self) : NULL;
}


static gpointer _timer_dup0 (gpointer self) {
	return self ? timer_dup (self) : NULL;
}


void systems_physics (Systems* self, Entity** player, gint tick) {
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	gboolean ground = FALSE;
	Game* _tmp10_ = NULL;
	Map* _tmp11_ = NULL;
	Entity* _tmp12_ = NULL;
	Point2d _tmp13_ = {0};
	Entity* _tmp14_ = NULL;
	Vector2d* _tmp15_ = NULL;
	Vector2d _tmp16_ = {0};
	gboolean _tmp17_ = FALSE;
	gboolean* _tmp18_ = NULL;
	gint _tmp18__length1 = 0;
	gboolean _tmp19_ = FALSE;
	gdouble direction = 0.0;
	gboolean* _tmp23_ = NULL;
	gint _tmp23__length1 = 0;
	gboolean _tmp24_ = FALSE;
	gboolean* _tmp25_ = NULL;
	gint _tmp25__length1 = 0;
	gboolean _tmp26_ = FALSE;
	Entity* _tmp27_ = NULL;
	Vector2d* _tmp28_ = NULL;
	Entity* _tmp29_ = NULL;
	Vector2d* _tmp30_ = NULL;
	gdouble _tmp31_ = 0.0;
	gboolean _tmp32_ = FALSE;
	Entity* _tmp45_ = NULL;
	Vector2d* _tmp46_ = NULL;
	Entity* _tmp47_ = NULL;
	Vector2d* _tmp48_ = NULL;
	gdouble _tmp49_ = 0.0;
	gdouble _tmp50_ = 0.0;
	Game* _tmp51_ = NULL;
	Map* _tmp52_ = NULL;
	Entity* _tmp53_ = NULL;
	Vector2d* _tmp54_ = NULL;
	Vector2d _tmp55_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = sdx_keys;
	_tmp0__length1 = sdx_keys_length1;
	_tmp1_ = _tmp0_[114];
	if (((gint) _tmp1_) == 1) {
		Point2d _tmp2_ = {0};
		Vector2d _tmp3_ = {0};
		Vector2d* _tmp4_ = NULL;
		Entity* _tmp5_ = NULL;
		Timer* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		Timer _tmp8_ = {0};
		Timer* _tmp9_ = NULL;
		_tmp2_.x = (gdouble) 170;
		_tmp2_.y = (gdouble) 500;
		(*(*player)).position = _tmp2_;
		_tmp3_.x = (gdouble) 0;
		_tmp3_.y = (gdouble) 0;
		_tmp4_ = _vector2d_dup0 (&_tmp3_);
		_vector2d_free0 ((*(*player)).velocity);
		(*(*player)).velocity = _tmp4_;
		_tmp5_ = *player;
		_tmp6_ = (*_tmp5_).expires;
		_tmp7_ = (*_tmp6_).best;
		_tmp8_.begin = 0;
		_tmp8_.finish = 0;
		_tmp8_.best = _tmp7_;
		_tmp9_ = _timer_dup0 (&_tmp8_);
		_timer_free0 ((*(*player)).expires);
		(*(*player)).expires = _tmp9_;
	}
	_tmp10_ = self->game;
	_tmp11_ = _tmp10_->map;
	_tmp12_ = *player;
	_tmp13_ = (*_tmp12_).position;
	_tmp14_ = *player;
	_tmp15_ = (*_tmp14_).size;
	_tmp16_ = *_tmp15_;
	_tmp17_ = map_onGround (_tmp11_, &_tmp13_, &_tmp16_);
	ground = _tmp17_;
	_tmp18_ = sdx_dir;
	_tmp18__length1 = sdx_dir_length1;
	_tmp19_ = _tmp18_[SDX_DIRECTION_UP];
	if (_tmp19_) {
		gboolean _tmp20_ = FALSE;
		_tmp20_ = ground;
		if (_tmp20_) {
			Entity* _tmp21_ = NULL;
			Vector2d* _tmp22_ = NULL;
			_tmp21_ = *player;
			_tmp22_ = (*_tmp21_).velocity;
			(*_tmp22_).y = (gdouble) (-21);
		}
	}
	_tmp23_ = sdx_dir;
	_tmp23__length1 = sdx_dir_length1;
	_tmp24_ = _tmp23_[SDX_DIRECTION_RIGHT];
	_tmp25_ = sdx_dir;
	_tmp25__length1 = sdx_dir_length1;
	_tmp26_ = _tmp25_[SDX_DIRECTION_LEFT];
	direction = (gdouble) (((gint) _tmp24_) - ((gint) _tmp26_));
	_tmp27_ = *player;
	_tmp28_ = (*_tmp27_).velocity;
	_tmp29_ = *player;
	_tmp30_ = (*_tmp29_).velocity;
	_tmp31_ = (*_tmp30_).y;
	(*_tmp30_).y = _tmp31_ + 0.75;
	_tmp32_ = ground;
	if (_tmp32_) {
		Entity* _tmp33_ = NULL;
		Vector2d* _tmp34_ = NULL;
		Entity* _tmp35_ = NULL;
		Vector2d* _tmp36_ = NULL;
		gdouble _tmp37_ = 0.0;
		gdouble _tmp38_ = 0.0;
		_tmp33_ = *player;
		_tmp34_ = (*_tmp33_).velocity;
		_tmp35_ = *player;
		_tmp36_ = (*_tmp35_).velocity;
		_tmp37_ = (*_tmp36_).x;
		_tmp38_ = direction;
		(*_tmp34_).x = (0.5 * _tmp37_) + (4.0 * _tmp38_);
	} else {
		Entity* _tmp39_ = NULL;
		Vector2d* _tmp40_ = NULL;
		Entity* _tmp41_ = NULL;
		Vector2d* _tmp42_ = NULL;
		gdouble _tmp43_ = 0.0;
		gdouble _tmp44_ = 0.0;
		_tmp39_ = *player;
		_tmp40_ = (*_tmp39_).velocity;
		_tmp41_ = *player;
		_tmp42_ = (*_tmp41_).velocity;
		_tmp43_ = (*_tmp42_).x;
		_tmp44_ = direction;
		(*_tmp40_).x = (0.95 * _tmp43_) + (2.0 * _tmp44_);
	}
	_tmp45_ = *player;
	_tmp46_ = (*_tmp45_).velocity;
	_tmp47_ = *player;
	_tmp48_ = (*_tmp47_).velocity;
	_tmp49_ = (*_tmp48_).x;
	_tmp50_ = clamp (_tmp49_, (gdouble) (-8), (gdouble) 8);
	(*_tmp46_).x = _tmp50_;
	_tmp51_ = self->game;
	_tmp52_ = _tmp51_->map;
	_tmp53_ = *player;
	_tmp54_ = (*_tmp53_).size;
	_tmp55_ = *_tmp54_;
	map_moveBox (_tmp52_, &(*(*player)).position, (*(*player)).velocity, &_tmp55_);
}


/**
 *  Camera
 */
void systems_camera (Systems* self, Entity** player, gint tick) {
	gdouble halfWin = 0.0;
	gint _tmp0_ = 0;
	Game* _tmp1_ = NULL;
	CameraType _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = WINDOW_SIZE.x;
	halfWin = ((gdouble) _tmp0_) / 2;
	_tmp1_ = self->game;
	_tmp2_ = _tmp1_->cameraType;
	if (_tmp2_ == CAMERA_TYPE_FLUID_CAMERA) {
		gdouble dist = 0.0;
		Game* _tmp3_ = NULL;
		Camera _tmp4_ = {0};
		gdouble _tmp5_ = 0.0;
		Entity* _tmp6_ = NULL;
		Point2d _tmp7_ = {0};
		gdouble _tmp8_ = 0.0;
		gdouble _tmp9_ = 0.0;
		Game* _tmp10_ = NULL;
		gdouble _tmp11_ = 0.0;
		_tmp3_ = self->game;
		_tmp4_ = _tmp3_->camera;
		_tmp5_ = _tmp4_.x;
		_tmp6_ = *player;
		_tmp7_ = (*_tmp6_).position;
		_tmp8_ = _tmp7_.x;
		_tmp9_ = halfWin;
		dist = (_tmp5_ - _tmp8_) + _tmp9_;
		_tmp10_ = self->game;
		_tmp11_ = dist;
		camera_scrollBy (&_tmp10_->camera, (-0.05) * _tmp11_);
	} else {
		Game* _tmp12_ = NULL;
		CameraType _tmp13_ = 0;
		_tmp12_ = self->game;
		_tmp13_ = _tmp12_->cameraType;
		if (_tmp13_ == CAMERA_TYPE_INNER_CAMERA) {
			gdouble leftArea = 0.0;
			Entity* _tmp14_ = NULL;
			Point2d _tmp15_ = {0};
			gdouble _tmp16_ = 0.0;
			gdouble _tmp17_ = 0.0;
			gdouble rightArea = 0.0;
			Entity* _tmp18_ = NULL;
			Point2d _tmp19_ = {0};
			gdouble _tmp20_ = 0.0;
			gdouble _tmp21_ = 0.0;
			Game* _tmp22_ = NULL;
			Game* _tmp23_ = NULL;
			Camera _tmp24_ = {0};
			gdouble _tmp25_ = 0.0;
			gdouble _tmp26_ = 0.0;
			gdouble _tmp27_ = 0.0;
			gdouble _tmp28_ = 0.0;
			_tmp14_ = *player;
			_tmp15_ = (*_tmp14_).position;
			_tmp16_ = _tmp15_.x;
			_tmp17_ = halfWin;
			leftArea = (_tmp16_ - _tmp17_) - 100;
			_tmp18_ = *player;
			_tmp19_ = (*_tmp18_).position;
			_tmp20_ = _tmp19_.x;
			_tmp21_ = halfWin;
			rightArea = (_tmp20_ - _tmp21_) + 100;
			_tmp22_ = self->game;
			_tmp23_ = self->game;
			_tmp24_ = _tmp23_->camera;
			_tmp25_ = _tmp24_.x;
			_tmp26_ = leftArea;
			_tmp27_ = rightArea;
			_tmp28_ = clamp (_tmp25_, _tmp26_, _tmp27_);
			camera_scrollTo (&_tmp22_->camera, _tmp28_);
		} else {
			Game* _tmp29_ = NULL;
			Entity* _tmp30_ = NULL;
			Point2d _tmp31_ = {0};
			gdouble _tmp32_ = 0.0;
			gdouble _tmp33_ = 0.0;
			_tmp29_ = self->game;
			_tmp30_ = *player;
			_tmp31_ = (*_tmp30_).position;
			_tmp32_ = _tmp31_.x;
			_tmp33_ = halfWin;
			camera_scrollTo (&_tmp29_->camera, _tmp32_ - _tmp33_);
		}
	}
}


/**
 *  Logic
 */
void systems_logic (Systems* self, Entity** player, gint tick) {
	Game* _tmp0_ = NULL;
	Map* _tmp1_ = NULL;
	Entity* _tmp2_ = NULL;
	Point2d _tmp3_ = {0};
	gdouble _tmp4_ = 0.0;
	Entity* _tmp5_ = NULL;
	Point2d _tmp6_ = {0};
	gdouble _tmp7_ = 0.0;
	gint _tmp8_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->game;
	_tmp1_ = _tmp0_->map;
	_tmp2_ = *player;
	_tmp3_ = (*_tmp2_).position;
	_tmp4_ = _tmp3_.x;
	_tmp5_ = *player;
	_tmp6_ = (*_tmp5_).position;
	_tmp7_ = _tmp6_.y;
	_tmp8_ = map_getTile (_tmp1_, _tmp4_, _tmp7_);
	switch (_tmp8_) {
		case MAP_START:
		{
			{
				Entity* _tmp9_ = NULL;
				Timer* _tmp10_ = NULL;
				gint _tmp11_ = 0;
				_tmp9_ = *player;
				_tmp10_ = (*_tmp9_).expires;
				_tmp11_ = tick;
				(*_tmp10_).begin = _tmp11_;
			}
			break;
		}
		case MAP_FINISH:
		{
			{
				Entity* _tmp12_ = NULL;
				Timer* _tmp13_ = NULL;
				gint _tmp14_ = 0;
				_tmp12_ = *player;
				_tmp13_ = (*_tmp12_).expires;
				_tmp14_ = (*_tmp13_).begin;
				if (_tmp14_ >= 0) {
					Entity* _tmp15_ = NULL;
					Timer* _tmp16_ = NULL;
					gint _tmp17_ = 0;
					Entity* _tmp18_ = NULL;
					Timer* _tmp19_ = NULL;
					gint _tmp20_ = 0;
					Entity* _tmp21_ = NULL;
					Timer* _tmp22_ = NULL;
					gboolean _tmp23_ = FALSE;
					Entity* _tmp24_ = NULL;
					Timer* _tmp25_ = NULL;
					gint _tmp26_ = 0;
					Entity* _tmp38_ = NULL;
					Timer* _tmp39_ = NULL;
					gint _tmp40_ = 0;
					gchar* _tmp41_ = NULL;
					gchar* _tmp42_ = NULL;
					_tmp15_ = *player;
					_tmp16_ = (*_tmp15_).expires;
					_tmp17_ = tick;
					_tmp18_ = *player;
					_tmp19_ = (*_tmp18_).expires;
					_tmp20_ = (*_tmp19_).begin;
					(*_tmp16_).finish = _tmp17_ - _tmp20_;
					_tmp21_ = *player;
					_tmp22_ = (*_tmp21_).expires;
					(*_tmp22_).begin = -1;
					_tmp24_ = *player;
					_tmp25_ = (*_tmp24_).expires;
					_tmp26_ = (*_tmp25_).best;
					if (_tmp26_ < 0) {
						_tmp23_ = TRUE;
					} else {
						Entity* _tmp27_ = NULL;
						Timer* _tmp28_ = NULL;
						gint _tmp29_ = 0;
						Entity* _tmp30_ = NULL;
						Timer* _tmp31_ = NULL;
						gint _tmp32_ = 0;
						_tmp27_ = *player;
						_tmp28_ = (*_tmp27_).expires;
						_tmp29_ = (*_tmp28_).finish;
						_tmp30_ = *player;
						_tmp31_ = (*_tmp30_).expires;
						_tmp32_ = (*_tmp31_).best;
						_tmp23_ = _tmp29_ < _tmp32_;
					}
					if (_tmp23_) {
						Entity* _tmp33_ = NULL;
						Timer* _tmp34_ = NULL;
						Entity* _tmp35_ = NULL;
						Timer* _tmp36_ = NULL;
						gint _tmp37_ = 0;
						_tmp33_ = *player;
						_tmp34_ = (*_tmp33_).expires;
						_tmp35_ = *player;
						_tmp36_ = (*_tmp35_).expires;
						_tmp37_ = (*_tmp36_).finish;
						(*_tmp34_).best = _tmp37_;
					}
					_tmp38_ = *player;
					_tmp39_ = (*_tmp38_).expires;
					_tmp40_ = (*_tmp39_).finish;
					_tmp41_ = formatTime (_tmp40_);
					_tmp42_ = _tmp41_;
					g_print ("Finished in %s\n", _tmp42_);
					_g_free0 (_tmp42_);
				}
			}
			break;
		}
		default:
		break;
	}
}


static void systems_instance_init (Systems * self) {
	self->retainCount__ = 1;
}


void systems_free (Systems* self) {
	_game_release0 (self->game);
	g_slice_free (Systems, self);
}



