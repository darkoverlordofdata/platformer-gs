/* Game.c generated by valac 0.34.8, the Vala compiler
 * generated from Game.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_pixels.h>
#include <SDL2/SDL_rect.h>


#define SDX_MATH_TYPE_VECTOR2 (sdx_math_vector2_get_type ())
typedef struct _sdxmathVector2 sdxmathVector2;
typedef struct _sdxAbstractPlatform sdxAbstractPlatform;
typedef sdxAbstractPlatform Game;

#define TYPE_ENTITY (entity_get_type ())

#define TYPE_CATEGORY (category_get_type ())

#define TYPE_ACTOR (actor_get_type ())

#define SDX_GRAPHICS_TYPE_RECT (sdx_graphics_rect_get_type ())
typedef SDL_Rect sdxgraphicsRect;
typedef struct _sdxgraphicsSprite sdxgraphicsSprite;

#define SDX_GRAPHICS_TYPE_COLOR (sdx_graphics_color_get_type ())
typedef SDL_Color sdxgraphicsColor;

#define TYPE_TIMER (timer_get_type ())
typedef struct _Timer Timer;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;
typedef struct _Entity Entity;
typedef struct _sdxgraphicsCamera sdxgraphicsCamera;
typedef sdxgraphicsCamera sdxgraphicsCameraInnerCamera;
typedef struct _Map Map;
typedef struct _System System;
typedef struct _Block1Data Block1Data;
void map_release (Map* self);
void map_free (Map* self);
Map* map_retain (Map* self);
#define _map_release0(var) ((var == NULL) ? NULL : (var = (map_release (var), NULL)))
void sdx_graphics_camera_release (sdxgraphicsCamera* self);
void sdx_graphics_camera_free (sdxgraphicsCamera* self);
sdxgraphicsCamera* sdx_graphics_camera_retain (sdxgraphicsCamera* self);
#define _sdx_graphics_camera_release0(var) ((var == NULL) ? NULL : (var = (sdx_graphics_camera_release (var), NULL)))
void sdx_abstract_platform_release (sdxAbstractPlatform* self);
void sdx_abstract_platform_free (sdxAbstractPlatform* self);
sdxAbstractPlatform* sdx_abstract_platform_retain (sdxAbstractPlatform* self);
#define _sdx_abstract_platform_release0(var) ((var == NULL) ? NULL : (var = (sdx_abstract_platform_release (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _Factory Factory;
typedef System LogicSystem;
typedef System PhysicsSystem;
typedef System HudSystem;
void system_release (System* self);
void system_free (System* self);
System* system_retain (System* self);
#define _system_release0(var) ((var == NULL) ? NULL : (var = (system_release (var), NULL)))

#define SDX_GRAPHICS_CAMERA_TYPE_KIND (sdx_graphics_camera_kind_get_type ())
void factory_release (Factory* self);
void factory_free (Factory* self);
Factory* factory_retain (Factory* self);
#define _factory_release0(var) ((var == NULL) ? NULL : (var = (factory_release (var), NULL)))

#define SDX_TYPE_DIRECTION (sdx_direction_get_type ())

struct _sdxmathVector2 {
	gfloat x;
	gfloat y;
};

typedef void (*sdxAbstractPlatformPlatformUpdate) (gint tick, void* user_data);
typedef void (*sdxAbstractPlatformPlatformRender) (gint tick, void* user_data);
struct _sdxAbstractPlatform {
	gint _retainCount;
	sdxAbstractPlatformPlatformUpdate update;
	gpointer update_target;
	GDestroyNotify update_target_destroy_notify;
	sdxAbstractPlatformPlatformRender render;
	gpointer render_target;
	GDestroyNotify render_target_destroy_notify;
};

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_PLAYER,
	CATEGORY_BONUS
} Category;

typedef enum  {
	ACTOR_DEFAULT,
	ACTOR_BACKGROUND,
	ACTOR_TEXT,
	ACTOR_PLAYER,
	ACTOR_BONUS,
	ACTOR_HUD
} Actor;

struct _Timer {
	gint begin;
	gint finish;
	gint best;
};

struct _Health {
	gint curHealth;
	gint maxHealth;
};

struct _Entity {
	gint id;
	gchar* name;
	gboolean active;
	Category category;
	Actor actor;
	sdxmathVector2 position;
	sdxgraphicsRect bounds;
	sdxgraphicsSprite* sprite;
	sdxmathVector2* size;
	sdxmathVector2* scale;
	sdxgraphicsColor* tint;
	Timer* expires;
	Health* health;
	sdxmathVector2* velocity;
};

struct _Block1Data {
	int _ref_count_;
	Game* self;
	Entity* player;
	sdxgraphicsCameraInnerCamera* camera;
	Map* map;
	System** systems;
	gint systems_length1;
	gint _systems_size_;
	gboolean touch;
};

typedef void (*SystemInitialize) (void* user_data);
typedef void (*SystemExecute) (Entity** player, gint tick, void* user_data);
typedef void (*SystemRender) (Entity** player, gint tick, void* user_data);
struct _System {
	gint _retainCount;
	SDL_Rect _dummy0_;
	SDL_Color _dummy1_;
	SystemInitialize initialize;
	gpointer initialize_target;
	GDestroyNotify initialize_target_destroy_notify;
	SystemExecute execute;
	gpointer execute_target;
	GDestroyNotify execute_target_destroy_notify;
	SystemRender render;
	gpointer render_target;
	GDestroyNotify render_target_destroy_notify;
};

typedef enum  {
	SDX_GRAPHICS_CAMERA_KIND_FluidCamera,
	SDX_GRAPHICS_CAMERA_KIND_InnerCamera,
	SDX_GRAPHICS_CAMERA_KIND_SimpleCamera
} sdxgraphicsCameraKind;

typedef void (*sdxgraphicsCameraCameraSetPosition) (sdxmathVector2* position, void* user_data);
struct _sdxgraphicsCamera {
	gint _retainCount;
	sdxgraphicsCameraKind kind;
	sdxmathVector2 position;
	sdxgraphicsCameraCameraSetPosition setPosition;
	gpointer setPosition_target;
	GDestroyNotify setPosition_target_destroy_notify;
};

typedef enum  {
	SDX_DIRECTION_NONE,
	SDX_DIRECTION_LEFT,
	SDX_DIRECTION_RIGHT,
	SDX_DIRECTION_UP,
	SDX_DIRECTION_DOWN
} sdxDirection;


extern GList* game_display;
GList* game_display = NULL;
extern Entity* game_pool;
extern gint game_pool_length1;
Entity* game_pool = NULL;
gint game_pool_length1 = 0;
extern SDL_Color sdx_bgdColor;
extern gint sdx_height;
extern gboolean* sdx_direction;
extern gint sdx_direction_length1;
extern gboolean sdx_mouseDown;
extern gint sdx_mouseY;
extern gint sdx_mouseX;
extern gint sdx_width;

GType sdx_math_vector2_get_type (void) G_GNUC_CONST;
sdxmathVector2* sdx_math_vector2_dup (const sdxmathVector2* self);
void sdx_math_vector2_free (sdxmathVector2* self);
void sdx_abstract_platform_free (sdxAbstractPlatform* self);
GType entity_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
GType sdx_graphics_rect_get_type (void) G_GNUC_CONST;
sdxgraphicsRect* sdx_graphics_rect_dup (const sdxgraphicsRect* self);
void sdx_graphics_rect_free (sdxgraphicsRect* self);
void sdx_graphics_sprite_free (sdxgraphicsSprite* self);
GType sdx_graphics_color_get_type (void) G_GNUC_CONST;
sdxgraphicsColor* sdx_graphics_color_dup (const sdxgraphicsColor* self);
void sdx_graphics_color_free (sdxgraphicsColor* self);
GType timer_get_type (void) G_GNUC_CONST;
Timer* timer_dup (const Timer* self);
void timer_free (Timer* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
Game* game_new (void);
void sdx_graphics_camera_free (sdxgraphicsCamera* self);
void map_free (Map* self);
void system_free (System* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
sdxAbstractPlatform* sdx_abstract_platform_new (void);
void sdx_setResourceBase (const gchar* path);
void sdx_setDefaultFont (const gchar* path, gint size);
void factory_free (Factory* self);
Factory* factory_new (void);
void factory_createBerry (Factory* self, Entity* result);
void factory_createPlayer (Factory* self, Entity* result);
static void _vala_Entity_array_free (Entity* array, gint array_length);
sdxgraphicsCameraInnerCamera* sdx_graphics_camera_inner_camera_new (gfloat x, gfloat y);
Map* map_new (const gchar* mapPath);
LogicSystem* logic_system_new (Map* map);
PhysicsSystem* physics_system_new (Map* map);
HudSystem* hud_system_new (void);
static void __lambda16_ (Block1Data* _data1_, gint tick);
gboolean game_processInput (gboolean touch);
GType sdx_graphics_camera_kind_get_type (void) G_GNUC_CONST;
static void ___lambda16__sdx_abstract_platform_platform_update (gint tick, gpointer self);
static void __lambda17_ (Block1Data* _data1_, gint tick);
void sdx_begin (void);
void map_render (Map* self, sdxgraphicsCamera* camera);
void sdx_math_vector2_sub (sdxmathVector2 *self, sdxmathVector2* v, sdxmathVector2* result);
void sdx_graphics_sprite_render (sdxgraphicsSprite* self, gint x, gint y, SDL_Rect* clip);
void sdx_end (void);
static void ___lambda17__sdx_abstract_platform_platform_render (gint tick, gpointer self);
GType sdx_direction_get_type (void) G_GNUC_CONST;
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const sdxmathVector2 WINDOW_SIZE = {(gfloat) 1280, (gfloat) 720};
extern const SDL_Color SDX_COLOR_LiteSlateBlue;

static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Game* self;
		self = _data1_->self;
		_data1_->systems = (_vala_array_free (_data1_->systems, _data1_->systems_length1, (GDestroyNotify) system_release), NULL);
		_map_release0 (_data1_->map);
		_sdx_graphics_camera_release0 (_data1_->camera);
		_sdx_abstract_platform_release0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void _vala_Entity_array_free (Entity* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			entity_destroy (&array[i]);
		}
	}
	g_free (array);
}


static gpointer _system_retain0 (gpointer self) {
	return self ? system_retain (self) : NULL;
}


static void __lambda16_ (Block1Data* _data1_, gint tick) {
	Game* self;
	gboolean _tmp0_ = FALSE;
	sdxgraphicsCameraInnerCamera* _tmp1_ = NULL;
	sdxgraphicsCameraCameraSetPosition _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	Entity* _tmp3_ = NULL;
	sdxmathVector2 _tmp4_ = {0};
	System** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	self = _data1_->self;
	_tmp0_ = game_processInput (_data1_->touch);
	_data1_->touch = _tmp0_;
	_tmp1_ = _data1_->camera;
	_tmp2_ = ((sdxgraphicsCamera*) _tmp1_)->setPosition;
	_tmp2__target = ((sdxgraphicsCamera*) _tmp1_)->setPosition_target;
	_tmp3_ = _data1_->player;
	_tmp4_ = (*_tmp3_).position;
	_tmp2_ (&_tmp4_, _tmp2__target);
	_tmp5_ = _data1_->systems;
	_tmp5__length1 = _data1_->systems_length1;
	{
		System** system_collection = NULL;
		gint system_collection_length1 = 0;
		gint _system_collection_size_ = 0;
		gint system_it = 0;
		system_collection = _tmp5_;
		system_collection_length1 = _tmp5__length1;
		for (system_it = 0; system_it < _tmp5__length1; system_it = system_it + 1) {
			System* _tmp6_ = NULL;
			System* system = NULL;
			_tmp6_ = _system_retain0 (system_collection[system_it]);
			system = _tmp6_;
			{
				System* _tmp7_ = NULL;
				SystemExecute _tmp8_ = NULL;
				void* _tmp8__target = NULL;
				gint _tmp9_ = 0;
				_tmp7_ = system;
				_tmp8_ = _tmp7_->execute;
				_tmp8__target = _tmp7_->execute_target;
				_tmp9_ = tick;
				_tmp8_ (&_data1_->player, _tmp9_, _tmp8__target);
				_system_release0 (system);
			}
		}
	}
}


static void ___lambda16__sdx_abstract_platform_platform_update (gint tick, gpointer self) {
	__lambda16_ (self, tick);
}


static void __lambda17_ (Block1Data* _data1_, gint tick) {
	Game* self;
	Map* _tmp0_ = NULL;
	sdxgraphicsCameraInnerCamera* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	System** _tmp12_ = NULL;
	gint _tmp12__length1 = 0;
	self = _data1_->self;
	sdx_begin ();
	_tmp0_ = _data1_->map;
	_tmp1_ = _data1_->camera;
	map_render (_tmp0_, (sdxgraphicsCamera*) _tmp1_);
	_tmp2_ = game_display;
	{
		GList* entity_collection = NULL;
		GList* entity_it = NULL;
		entity_collection = _tmp2_;
		for (entity_it = entity_collection; entity_it != NULL; entity_it = entity_it->next) {
			Entity* entity = NULL;
			entity = entity_it->data;
			{
				sdxmathVector2 position = {0};
				sdxgraphicsCameraInnerCamera* _tmp3_ = NULL;
				sdxmathVector2 _tmp4_ = {0};
				sdxmathVector2 _tmp5_ = {0};
				Entity* _tmp6_ = NULL;
				sdxgraphicsSprite* _tmp7_ = NULL;
				sdxmathVector2 _tmp8_ = {0};
				gfloat _tmp9_ = 0.0F;
				sdxmathVector2 _tmp10_ = {0};
				gfloat _tmp11_ = 0.0F;
				_tmp3_ = _data1_->camera;
				_tmp4_ = ((sdxgraphicsCamera*) _tmp3_)->position;
				sdx_math_vector2_sub (&(*entity).position, &_tmp4_, &_tmp5_);
				position = _tmp5_;
				_tmp6_ = entity;
				_tmp7_ = (*_tmp6_).sprite;
				_tmp8_ = position;
				_tmp9_ = _tmp8_.x;
				_tmp10_ = position;
				_tmp11_ = _tmp10_.y;
				sdx_graphics_sprite_render (_tmp7_, (gint) _tmp9_, (gint) _tmp11_, NULL);
			}
		}
	}
	_tmp12_ = _data1_->systems;
	_tmp12__length1 = _data1_->systems_length1;
	{
		System** system_collection = NULL;
		gint system_collection_length1 = 0;
		gint _system_collection_size_ = 0;
		gint system_it = 0;
		system_collection = _tmp12_;
		system_collection_length1 = _tmp12__length1;
		for (system_it = 0; system_it < _tmp12__length1; system_it = system_it + 1) {
			System* _tmp13_ = NULL;
			System* system = NULL;
			_tmp13_ = _system_retain0 (system_collection[system_it]);
			system = _tmp13_;
			{
				System* _tmp14_ = NULL;
				SystemRender _tmp15_ = NULL;
				void* _tmp15__target = NULL;
				gint _tmp16_ = 0;
				_tmp14_ = system;
				_tmp15_ = _tmp14_->render;
				_tmp15__target = _tmp14_->render_target;
				_tmp16_ = tick;
				_tmp15_ (&_data1_->player, _tmp16_, _tmp15__target);
				_system_release0 (system);
			}
		}
	}
	sdx_end ();
}


static void ___lambda17__sdx_abstract_platform_platform_render (gint tick, gpointer self) {
	__lambda17_ (self, tick);
}


Game* game_new (void) {
	Game* self;
	Block1Data* _data1_;
	Factory* factory = NULL;
	Factory* _tmp0_ = NULL;
	Factory* _tmp1_ = NULL;
	Entity _tmp2_ = {0};
	Factory* _tmp3_ = NULL;
	Entity _tmp4_ = {0};
	Entity* _tmp5_ = NULL;
	Entity* _tmp6_ = NULL;
	gint _tmp6__length1 = 0;
	sdxgraphicsCameraInnerCamera* _tmp13_ = NULL;
	Map* _tmp14_ = NULL;
	Map* _tmp15_ = NULL;
	LogicSystem* _tmp16_ = NULL;
	Map* _tmp17_ = NULL;
	PhysicsSystem* _tmp18_ = NULL;
	HudSystem* _tmp19_ = NULL;
	System** _tmp20_ = NULL;
	System** _tmp21_ = NULL;
	gint _tmp21__length1 = 0;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	self = (Game*) sdx_abstract_platform_new ();
	_data1_->self = sdx_abstract_platform_retain (self);
	_g_list_free0 (game_display);
	game_display = NULL;
	sdx_bgdColor = SDX_COLOR_LiteSlateBlue;
	sdx_setResourceBase ("/darkoverlordofdata/platformer");
	sdx_setDefaultFont ("assets/OpenDyslexic-Bold.otf", 28);
	_tmp0_ = factory_new ();
	factory = _tmp0_;
	_tmp1_ = factory;
	factory_createBerry (_tmp1_, &_tmp2_);
	_tmp3_ = factory;
	factory_createPlayer (_tmp3_, &_tmp4_);
	_tmp5_ = g_new0 (Entity, 2);
	_tmp5_[0] = _tmp2_;
	_tmp5_[1] = _tmp4_;
	game_pool = (_vala_Entity_array_free (game_pool, game_pool_length1), NULL);
	game_pool = _tmp5_;
	game_pool_length1 = 2;
	_tmp6_ = game_pool;
	_tmp6__length1 = game_pool_length1;
	_data1_->player = &_tmp6_[1];
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = TRUE;
			while (TRUE) {
				gint _tmp9_ = 0;
				Entity* _tmp10_ = NULL;
				gint _tmp10__length1 = 0;
				Entity* _tmp11_ = NULL;
				gint _tmp11__length1 = 0;
				gint _tmp12_ = 0;
				if (!_tmp7_) {
					gint _tmp8_ = 0;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp7_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = game_pool;
				_tmp10__length1 = game_pool_length1;
				if (!(_tmp9_ < _tmp10__length1)) {
					break;
				}
				_tmp11_ = game_pool;
				_tmp11__length1 = game_pool_length1;
				_tmp12_ = i;
				game_display = g_list_append (game_display, &_tmp11_[_tmp12_]);
			}
		}
	}
	_tmp13_ = sdx_graphics_camera_inner_camera_new ((gfloat) 0, (gfloat) 0);
	_data1_->camera = _tmp13_;
	_tmp14_ = map_new ("assets/default.json");
	_data1_->map = _tmp14_;
	_tmp15_ = _data1_->map;
	_tmp16_ = logic_system_new (_tmp15_);
	_tmp17_ = _data1_->map;
	_tmp18_ = physics_system_new (_tmp17_);
	_tmp19_ = hud_system_new ();
	_tmp20_ = g_new0 (System*, 3 + 1);
	_tmp20_[0] = (System*) _tmp16_;
	_tmp20_[1] = (System*) _tmp18_;
	_tmp20_[2] = (System*) _tmp19_;
	_data1_->systems = _tmp20_;
	_data1_->systems_length1 = 3;
	_data1_->_systems_size_ = _data1_->systems_length1;
	_tmp21_ = _data1_->systems;
	_tmp21__length1 = _data1_->systems_length1;
	{
		System** system_collection = NULL;
		gint system_collection_length1 = 0;
		gint _system_collection_size_ = 0;
		gint system_it = 0;
		system_collection = _tmp21_;
		system_collection_length1 = _tmp21__length1;
		for (system_it = 0; system_it < _tmp21__length1; system_it = system_it + 1) {
			System* _tmp22_ = NULL;
			System* system = NULL;
			_tmp22_ = _system_retain0 (system_collection[system_it]);
			system = _tmp22_;
			{
				System* _tmp23_ = NULL;
				SystemInitialize _tmp24_ = NULL;
				void* _tmp24__target = NULL;
				_tmp23_ = system;
				_tmp24_ = _tmp23_->initialize;
				_tmp24__target = _tmp23_->initialize_target;
				_tmp24_ (_tmp24__target);
				_system_release0 (system);
			}
		}
	}
	_data1_->touch = FALSE;
	(((sdxAbstractPlatform*) self)->update_target_destroy_notify == NULL) ? NULL : (((sdxAbstractPlatform*) self)->update_target_destroy_notify (((sdxAbstractPlatform*) self)->update_target), NULL);
	((sdxAbstractPlatform*) self)->update = NULL;
	((sdxAbstractPlatform*) self)->update_target = NULL;
	((sdxAbstractPlatform*) self)->update_target_destroy_notify = NULL;
	((sdxAbstractPlatform*) self)->update = ___lambda16__sdx_abstract_platform_platform_update;
	((sdxAbstractPlatform*) self)->update_target = block1_data_ref (_data1_);
	((sdxAbstractPlatform*) self)->update_target_destroy_notify = block1_data_unref;
	(((sdxAbstractPlatform*) self)->render_target_destroy_notify == NULL) ? NULL : (((sdxAbstractPlatform*) self)->render_target_destroy_notify (((sdxAbstractPlatform*) self)->render_target), NULL);
	((sdxAbstractPlatform*) self)->render = NULL;
	((sdxAbstractPlatform*) self)->render_target = NULL;
	((sdxAbstractPlatform*) self)->render_target_destroy_notify = NULL;
	((sdxAbstractPlatform*) self)->render = ___lambda17__sdx_abstract_platform_platform_render;
	((sdxAbstractPlatform*) self)->render_target = block1_data_ref (_data1_);
	((sdxAbstractPlatform*) self)->render_target_destroy_notify = block1_data_unref;
	_factory_release0 (factory);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return self;
}


/**
 *	map touch input for android into left/right/jump
 * 
 * 	 +------------------- // // --------------------+
 * 	 | (0, 0) |                            | (w, 0) |
 * 	 |        |  	        	       	   |        |
 * 	 |   J    |                            |   J    |
 * 	 |        |                            |        |
 * 	 +--------+                            +--------+
 * 	 |        |                            |        |
 * 	 |        |                            |        |
 * 	 |   LJ   |                            |   RJ   |
 * 	 |        |                            |        |
 * 	 +--------+                            +--------+
 * 	 |        |                            |        |
 * 	 |    L   |                            |    R   |
 * 	 |        |                            |        |
 * 	 | (0, h) |                            | (w, h) |
 * 	 +------------------- // // --------------------+
 * 
 */
gboolean game_processInput (gboolean touch) {
	gboolean result = FALSE;
	gint sz = 0;
	gint _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp24_ = FALSE;
	_tmp0_ = sdx_height;
	sz = _tmp0_ / 3;
	_tmp1_ = touch;
	if (_tmp1_) {
		gboolean* _tmp2_ = NULL;
		gint _tmp2__length1 = 0;
		gboolean _tmp3_ = FALSE;
		gboolean* _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		gboolean _tmp5_ = FALSE;
		gboolean* _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		gboolean _tmp7_ = FALSE;
		gboolean* _tmp8_ = NULL;
		gint _tmp8__length1 = 0;
		gboolean _tmp9_ = FALSE;
		_tmp2_ = sdx_direction;
		_tmp2__length1 = sdx_direction_length1;
		_tmp2_[SDX_DIRECTION_LEFT] = FALSE;
		_tmp3_ = _tmp2_[SDX_DIRECTION_LEFT];
		_tmp4_ = sdx_direction;
		_tmp4__length1 = sdx_direction_length1;
		_tmp4_[SDX_DIRECTION_RIGHT] = FALSE;
		_tmp5_ = _tmp4_[SDX_DIRECTION_RIGHT];
		_tmp6_ = sdx_direction;
		_tmp6__length1 = sdx_direction_length1;
		_tmp6_[SDX_DIRECTION_UP] = FALSE;
		_tmp7_ = _tmp6_[SDX_DIRECTION_UP];
		_tmp8_ = sdx_direction;
		_tmp8__length1 = sdx_direction_length1;
		_tmp8_[SDX_DIRECTION_DOWN] = FALSE;
		_tmp9_ = _tmp8_[SDX_DIRECTION_DOWN];
		touch = FALSE;
	}
	_tmp10_ = sdx_mouseDown;
	if (_tmp10_) {
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		gint _tmp15_ = 0;
		gint _tmp16_ = 0;
		touch = TRUE;
		_tmp11_ = sdx_mouseY;
		_tmp12_ = sz;
		if (_tmp11_ < (_tmp12_ * 2)) {
			gboolean* _tmp13_ = NULL;
			gint _tmp13__length1 = 0;
			gboolean _tmp14_ = FALSE;
			_tmp13_ = sdx_direction;
			_tmp13__length1 = sdx_direction_length1;
			_tmp13_[SDX_DIRECTION_UP] = TRUE;
			_tmp14_ = _tmp13_[SDX_DIRECTION_UP];
		}
		_tmp15_ = sdx_mouseX;
		_tmp16_ = sz;
		if (_tmp15_ < _tmp16_) {
			gboolean* _tmp17_ = NULL;
			gint _tmp17__length1 = 0;
			gboolean _tmp18_ = FALSE;
			_tmp17_ = sdx_direction;
			_tmp17__length1 = sdx_direction_length1;
			_tmp17_[SDX_DIRECTION_LEFT] = TRUE;
			_tmp18_ = _tmp17_[SDX_DIRECTION_LEFT];
		} else {
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			_tmp19_ = sdx_mouseX;
			_tmp20_ = sdx_width;
			_tmp21_ = sz;
			if (_tmp19_ > (_tmp20_ - _tmp21_)) {
				gboolean* _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				gboolean _tmp23_ = FALSE;
				_tmp22_ = sdx_direction;
				_tmp22__length1 = sdx_direction_length1;
				_tmp22_[SDX_DIRECTION_RIGHT] = TRUE;
				_tmp23_ = _tmp22_[SDX_DIRECTION_RIGHT];
			}
		}
	}
	_tmp24_ = touch;
	result = _tmp24_;
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



