/* Map.c generated by valac 0.34.8, the Vala compiler
 * generated from Map.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <SDL2/SDL_render.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_rect.h>

typedef struct _Map Map;
#define _g_free0(var) ((var == NULL) ? NULL : (var = (g_free (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_COLLISION (collision_get_type ())

struct _Map {
	gint retainCount__;
	gint width;
	gint height;
	gchar** lines;
	gint lines_length1;
	guint8* buf;
	gint buf_length1;
	struct stat* stat;
	gchar* ioBuff;
	gint ioBuff_length1;
	GList* tiles;
	SDL_Texture* texture;
};

typedef enum  {
	EXCEPTION_SDLException,
	EXCEPTION_InvalidValue
} Exception;
#define EXCEPTION exception_quark ()
struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

typedef enum  {
	COLLISION_x,
	COLLISION_y,
	COLLISION_corner
} Collision;



void map_release (Map* self);
Map* map_retain (Map* self);
void map_free (Map* self);
static void map_instance_init (Map * self);
Map* map_retain (Map* self);
void map_release (Map* self);
void map_release (Map* self);
Map* map_retain (Map* self);
void map_free (Map* self);
Map* map_new (SDL_Texture* texture, const gchar* filename);
static struct stat* _stat_dup (struct stat* self);
GQuark exception_quark (void);
gint map_getTile (Map* self, gdouble x, gdouble y);
gdouble clamp (gdouble value, gdouble low, gdouble hi);
gboolean map_isSolid (Map* self, gdouble x, gdouble y);
#define AIR 0
#define START 78
#define FINISH 110
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
gboolean map_onGround (Map* self, Point2d* pos, Vector2d* size);
gboolean map_testBox (Map* self, Point2d* pos, Vector2d* size);
void map_moveBox (Map* self, Point2d* pos, Vector2d* vel, Vector2d* size);
GType collision_get_type (void) G_GNUC_CONST;
gdouble vector2d_len (Vector2d *self);
void point2d_add (Point2d *self, Vector2d* v, Point2d* result);
void vector2d_mul (Vector2d *self, gdouble f, Vector2d* result);
void point2d (gdouble x, gdouble y, Point2d* result);
void vector2d (gdouble x, gdouble y, Vector2d* result);
void map_render (Map* self, SDL_Renderer* renderer, Vector2d* camera);
void rect (gint x, gint y, gint h, gint w, SDL_Rect* result);
#define TILES_PER_ROW 16
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

extern const SDL_Point TILES_SIZE;

Map* map_retain (Map* self) {
	Map* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->retainCount__), 1);
	result = self;
	return result;
}


void map_release (Map* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->retainCount__));
	if (_tmp0_) {
		map_free (self);
	}
}


static struct stat* _stat_dup (struct stat* self) {
	struct stat* dup;
	dup = g_new0 (struct stat, 1);
	memcpy (dup, self, sizeof (struct stat));
	return dup;
}


static gpointer __stat_dup0 (gpointer self) {
	return self ? _stat_dup (self) : NULL;
}


Map* map_new (SDL_Texture* texture, const gchar* filename) {
	Map* self;
	SDL_Texture* _tmp0_ = NULL;
	gchar* line = NULL;
	gchar* _tmp1_ = NULL;
	gchar* l2 = NULL;
	gchar* _tmp2_ = NULL;
	gchar* path = NULL;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gint exists = 0;
	const gchar* _tmp6_ = NULL;
	struct stat _tmp7_ = {0};
	gint _tmp8_ = 0;
	struct stat _tmp9_ = {0};
	struct stat* _tmp10_ = NULL;
	gboolean isFile = FALSE;
	struct stat* _tmp11_ = NULL;
	mode_t _tmp12_ = {0};
	gboolean _tmp13_ = FALSE;
	gint size = 0;
	struct stat* _tmp14_ = NULL;
	gsize _tmp15_ = 0UL;
	gint _tmp16_ = 0;
	gchar* _tmp17_ = NULL;
	FILE* hFile = NULL;
	const gchar* _tmp18_ = NULL;
	FILE* _tmp19_ = NULL;
	gint i = 0;
	gboolean eof = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (texture != NULL, NULL);
	g_return_val_if_fail (filename != NULL, NULL);
	self = g_slice_new0 (Map);
	map_instance_init (self);
	_tmp0_ = texture;
	self->texture = _tmp0_;
	_g_list_free0 (self->tiles);
	self->tiles = NULL;
	_tmp1_ = g_strdup ("");
	line = _tmp1_;
	_tmp2_ = g_strdup ("");
	l2 = _tmp2_;
	_tmp3_ = self->buf;
	_tmp3__length1 = self->buf_length1;
	_tmp4_ = realpath ("assets/default.map", _tmp3_);
	path = (gchar*) _tmp4_;
	_tmp5_ = path;
	g_print ("%s\n", _tmp5_);
	_tmp6_ = path;
	_tmp8_ = stat (_tmp6_, &_tmp7_);
	_g_free0 (self->stat);
	_tmp9_ = _tmp7_;
	_tmp10_ = __stat_dup0 (&_tmp9_);
	self->stat = _tmp10_;
	exists = _tmp8_;
	_tmp11_ = self->stat;
	_tmp12_ = (*_tmp11_).st_mode;
	_tmp13_ = S_ISREG (_tmp12_);
	isFile = _tmp13_;
	_tmp14_ = self->stat;
	_tmp15_ = (*_tmp14_).st_size;
	size = (gint) _tmp15_;
	_tmp16_ = size;
	_tmp17_ = g_new0 (gchar, _tmp16_ + 1);
	self->ioBuff = (g_free (self->ioBuff), NULL);
	self->ioBuff = _tmp17_;
	self->ioBuff_length1 = _tmp16_ + 1;
	_tmp18_ = path;
	_tmp19_ = fopen (_tmp18_, "r");
	hFile = _tmp19_;
	i = 0;
	eof = FALSE;
	while (TRUE) {
		gboolean _tmp20_ = FALSE;
		FILE* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		gint _tmp22__length1 = 0;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		_tmp20_ = eof;
		if (!(!_tmp20_)) {
			break;
		}
		_tmp21_ = hFile;
		_tmp22_ = self->ioBuff;
		_tmp22__length1 = self->ioBuff_length1;
		_tmp23_ = fgets (_tmp22_, _tmp22__length1, _tmp21_);
		_tmp24_ = g_strdup ((const gchar*) _tmp23_);
		_g_free0 (line);
		line = _tmp24_;
		_tmp25_ = line;
		g_print ("%s\n", _tmp25_);
		_tmp26_ = line;
		if (g_strcmp0 (_tmp26_, "EOF") == 0) {
			eof = TRUE;
		} else {
			gint width = 0;
			const gchar* _tmp27_ = NULL;
			gchar** _tmp28_ = NULL;
			gchar** _tmp29_ = NULL;
			gboolean _tmp44_ = FALSE;
			gint _tmp45_ = 0;
			gint _tmp49_ = 0;
			gint _tmp50_ = 0;
			width = 0;
			_tmp27_ = line;
			_tmp29_ = _tmp28_ = g_strsplit (_tmp27_, " ", 0);
			{
				gchar** word_collection = NULL;
				gint word_collection_length1 = 0;
				gint _word_collection_size_ = 0;
				gint word_it = 0;
				word_collection = _tmp29_;
				word_collection_length1 = _vala_array_length (_tmp28_);
				for (word_it = 0; word_it < _vala_array_length (_tmp28_); word_it = word_it + 1) {
					gchar* _tmp30_ = NULL;
					gchar* word = NULL;
					_tmp30_ = g_strdup (word_collection[word_it]);
					word = _tmp30_;
					{
						const gchar* _tmp31_ = NULL;
						gint value = 0;
						const gchar* _tmp32_ = NULL;
						gint _tmp33_ = 0;
						gint _tmp34_ = 0;
						gint _tmp42_ = 0;
						gint _tmp43_ = 0;
						_tmp31_ = word;
						if (g_strcmp0 (_tmp31_, "") == 0) {
							_g_free0 (word);
							continue;
						}
						_tmp32_ = word;
						_tmp33_ = atoi (_tmp32_);
						value = _tmp33_;
						_tmp34_ = value;
						if (_tmp34_ > 255) {
							const gchar* _tmp35_ = NULL;
							gchar* _tmp36_ = NULL;
							gchar* _tmp37_ = NULL;
							gchar* _tmp38_ = NULL;
							gchar* _tmp39_ = NULL;
							GError* _tmp40_ = NULL;
							GError* _tmp41_ = NULL;
							_tmp35_ = word;
							_tmp36_ = g_strconcat ("Invalid value +", _tmp35_, NULL);
							_tmp37_ = _tmp36_;
							_tmp38_ = g_strconcat (_tmp37_, " in map ", NULL);
							_tmp39_ = _tmp38_;
							_tmp40_ = g_error_new_literal (EXCEPTION, EXCEPTION_InvalidValue, _tmp39_);
							_tmp41_ = _tmp40_;
							_g_free0 (_tmp39_);
							_g_free0 (_tmp37_);
							_inner_error_ = _tmp41_;
							_g_free0 (word);
							word_collection = (_vala_array_free (word_collection, word_collection_length1, (GDestroyNotify) g_free), NULL);
							_fclose0 (hFile);
							_g_free0 (path);
							_g_free0 (l2);
							_g_free0 (line);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
						_tmp42_ = value;
						self->tiles = g_list_append (self->tiles, (gpointer) ((guintptr) ((guint8) _tmp42_)));
						_tmp43_ = width;
						width = _tmp43_ + 1;
						_g_free0 (word);
					}
				}
				word_collection = (_vala_array_free (word_collection, word_collection_length1, (GDestroyNotify) g_free), NULL);
			}
			_tmp45_ = self->width;
			if (_tmp45_ > 0) {
				gint _tmp46_ = 0;
				gint _tmp47_ = 0;
				_tmp46_ = self->width;
				_tmp47_ = width;
				_tmp44_ = _tmp46_ != _tmp47_;
			} else {
				_tmp44_ = FALSE;
			}
			if (_tmp44_) {
				GError* _tmp48_ = NULL;
				_tmp48_ = g_error_new_literal (EXCEPTION, EXCEPTION_InvalidValue, "Incompatible line length in map ");
				_inner_error_ = _tmp48_;
				_fclose0 (hFile);
				_g_free0 (path);
				_g_free0 (l2);
				_g_free0 (line);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_tmp49_ = width;
			self->width = _tmp49_;
			_tmp50_ = self->height;
			self->height = _tmp50_ + 1;
		}
	}
	_fclose0 (hFile);
	_g_free0 (path);
	_g_free0 (l2);
	_g_free0 (line);
	return self;
}


gint map_getTile (Map* self, gdouble x, gdouble y) {
	gint result = 0;
	gint nx = 0;
	gdouble _tmp0_ = 0.0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gdouble _tmp3_ = 0.0;
	gint ny = 0;
	gdouble _tmp4_ = 0.0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gdouble _tmp7_ = 0.0;
	gint pos = 0;
	gint _tmp8_ = 0;
	GList* _tmp9_ = NULL;
	gconstpointer _tmp10_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = x;
	_tmp1_ = TILES_SIZE.x;
	_tmp2_ = self->width;
	_tmp3_ = clamp (_tmp0_ / _tmp1_, (gdouble) 0, (gdouble) (_tmp2_ - 1));
	nx = (gint) _tmp3_;
	_tmp4_ = y;
	_tmp5_ = TILES_SIZE.y;
	_tmp6_ = self->height;
	_tmp7_ = clamp (_tmp4_ / _tmp5_, (gdouble) 0, (gdouble) (_tmp6_ - 1));
	ny = (gint) _tmp7_;
	_tmp8_ = self->width;
	pos = (ny * _tmp8_) + nx;
	_tmp9_ = self->tiles;
	_tmp10_ = g_list_nth_data (_tmp9_, (guint) pos);
	result = (gint) ((guint8) ((guintptr) _tmp10_));
	return result;
}


gboolean map_isSolid (Map* self, gdouble x, gdouble y) {
	gboolean result = FALSE;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_ = map_getTile (self, _tmp0_, _tmp1_);
	switch (_tmp2_) {
		case AIR:
		{
			{
				result = FALSE;
				return result;
			}
			break;
		}
		case START:
		{
			{
				result = FALSE;
				return result;
			}
			break;
		}
		case FINISH:
		{
			{
				result = FALSE;
				return result;
			}
			break;
		}
		default:
		break;
	}
	result = TRUE;
	return result;
}


gboolean map_onGround (Map* self, Point2d* pos, Vector2d* size) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	Point2d _tmp1_ = {0};
	gdouble _tmp2_ = 0.0;
	Vector2d _tmp3_ = {0};
	gdouble _tmp4_ = 0.0;
	Point2d _tmp5_ = {0};
	gdouble _tmp6_ = 0.0;
	Vector2d _tmp7_ = {0};
	gdouble _tmp8_ = 0.0;
	gboolean _tmp9_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pos != NULL, FALSE);
	g_return_val_if_fail (size != NULL, FALSE);
	_tmp1_ = *pos;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = *size;
	_tmp4_ = _tmp3_.x;
	_tmp5_ = *pos;
	_tmp6_ = _tmp5_.y;
	_tmp7_ = *size;
	_tmp8_ = _tmp7_.y;
	_tmp9_ = map_isSolid (self, _tmp2_ - (_tmp4_ * 0.5), (_tmp6_ + (_tmp8_ * 0.5)) + 1);
	if (_tmp9_) {
		_tmp0_ = TRUE;
	} else {
		Point2d _tmp10_ = {0};
		gdouble _tmp11_ = 0.0;
		Vector2d _tmp12_ = {0};
		gdouble _tmp13_ = 0.0;
		Point2d _tmp14_ = {0};
		gdouble _tmp15_ = 0.0;
		Vector2d _tmp16_ = {0};
		gdouble _tmp17_ = 0.0;
		gboolean _tmp18_ = FALSE;
		_tmp10_ = *pos;
		_tmp11_ = _tmp10_.x;
		_tmp12_ = *size;
		_tmp13_ = _tmp12_.x;
		_tmp14_ = *pos;
		_tmp15_ = _tmp14_.y;
		_tmp16_ = *size;
		_tmp17_ = _tmp16_.y;
		_tmp18_ = map_isSolid (self, _tmp11_ + (_tmp13_ * 0.5), (_tmp15_ + (_tmp17_ * 0.5)) + 1);
		_tmp0_ = _tmp18_;
	}
	result = _tmp0_;
	return result;
}


gboolean map_testBox (Map* self, Point2d* pos, Vector2d* size) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	Point2d _tmp3_ = {0};
	gdouble _tmp4_ = 0.0;
	Vector2d _tmp5_ = {0};
	gdouble _tmp6_ = 0.0;
	Point2d _tmp7_ = {0};
	gdouble _tmp8_ = 0.0;
	Vector2d _tmp9_ = {0};
	gdouble _tmp10_ = 0.0;
	gboolean _tmp11_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pos != NULL, FALSE);
	g_return_val_if_fail (size != NULL, FALSE);
	_tmp3_ = *pos;
	_tmp4_ = _tmp3_.x;
	_tmp5_ = *size;
	_tmp6_ = _tmp5_.x;
	_tmp7_ = *pos;
	_tmp8_ = _tmp7_.y;
	_tmp9_ = *size;
	_tmp10_ = _tmp9_.y;
	_tmp11_ = map_isSolid (self, _tmp4_ - (_tmp6_ * 0.5), _tmp8_ - (_tmp10_ * 0.5));
	if (_tmp11_) {
		_tmp2_ = TRUE;
	} else {
		Point2d _tmp12_ = {0};
		gdouble _tmp13_ = 0.0;
		Vector2d _tmp14_ = {0};
		gdouble _tmp15_ = 0.0;
		Point2d _tmp16_ = {0};
		gdouble _tmp17_ = 0.0;
		Vector2d _tmp18_ = {0};
		gdouble _tmp19_ = 0.0;
		gboolean _tmp20_ = FALSE;
		_tmp12_ = *pos;
		_tmp13_ = _tmp12_.x;
		_tmp14_ = *size;
		_tmp15_ = _tmp14_.x;
		_tmp16_ = *pos;
		_tmp17_ = _tmp16_.y;
		_tmp18_ = *size;
		_tmp19_ = _tmp18_.y;
		_tmp20_ = map_isSolid (self, _tmp13_ + (_tmp15_ * 0.5), _tmp17_ - (_tmp19_ * 0.5));
		_tmp2_ = _tmp20_;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		Point2d _tmp21_ = {0};
		gdouble _tmp22_ = 0.0;
		Vector2d _tmp23_ = {0};
		gdouble _tmp24_ = 0.0;
		Point2d _tmp25_ = {0};
		gdouble _tmp26_ = 0.0;
		Vector2d _tmp27_ = {0};
		gdouble _tmp28_ = 0.0;
		gboolean _tmp29_ = FALSE;
		_tmp21_ = *pos;
		_tmp22_ = _tmp21_.x;
		_tmp23_ = *size;
		_tmp24_ = _tmp23_.x;
		_tmp25_ = *pos;
		_tmp26_ = _tmp25_.y;
		_tmp27_ = *size;
		_tmp28_ = _tmp27_.y;
		_tmp29_ = map_isSolid (self, _tmp22_ - (_tmp24_ * 0.5), _tmp26_ + (_tmp28_ * 0.5));
		_tmp1_ = _tmp29_;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		Point2d _tmp30_ = {0};
		gdouble _tmp31_ = 0.0;
		Vector2d _tmp32_ = {0};
		gdouble _tmp33_ = 0.0;
		Point2d _tmp34_ = {0};
		gdouble _tmp35_ = 0.0;
		Vector2d _tmp36_ = {0};
		gdouble _tmp37_ = 0.0;
		gboolean _tmp38_ = FALSE;
		_tmp30_ = *pos;
		_tmp31_ = _tmp30_.x;
		_tmp32_ = *size;
		_tmp33_ = _tmp32_.x;
		_tmp34_ = *pos;
		_tmp35_ = _tmp34_.y;
		_tmp36_ = *size;
		_tmp37_ = _tmp36_.y;
		_tmp38_ = map_isSolid (self, _tmp31_ + (_tmp33_ * 0.5), _tmp35_ + (_tmp37_ * 0.5));
		_tmp0_ = _tmp38_;
	}
	result = _tmp0_;
	return result;
}


void map_moveBox (Map* self, Point2d* pos, Vector2d* vel, Vector2d* size) {
	GList* _result_ = NULL;
	gdouble distance = 0.0;
	gdouble _tmp0_ = 0.0;
	gint maximum = 0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble fraction = 0.0;
	gint _tmp3_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (pos != NULL);
	g_return_if_fail (vel != NULL);
	g_return_if_fail (size != NULL);
	_result_ = NULL;
	_tmp0_ = vector2d_len (vel);
	distance = _tmp0_;
	_tmp1_ = distance;
	maximum = (gint) _tmp1_;
	_tmp2_ = distance;
	if (_tmp2_ < ((gdouble) 0)) {
		_g_list_free0 (_result_);
		return;
	}
	_tmp3_ = maximum;
	fraction = 1.0 / ((gdouble) (_tmp3_ + 1));
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				gint _tmp6_ = 0;
				Point2d newPos = {0};
				gdouble _tmp7_ = 0.0;
				Vector2d _tmp8_ = {0};
				Point2d _tmp9_ = {0};
				Point2d _tmp10_ = {0};
				Vector2d _tmp11_ = {0};
				gboolean _tmp12_ = FALSE;
				Point2d _tmp34_ = {0};
				if (!_tmp4_) {
					gint _tmp5_ = 0;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp6_ = maximum;
				if (!(i <= _tmp6_)) {
					break;
				}
				_tmp7_ = fraction;
				vector2d_mul (vel, _tmp7_, &_tmp8_);
				point2d_add (pos, &_tmp8_, &_tmp9_);
				newPos = _tmp9_;
				_tmp10_ = newPos;
				_tmp11_ = *size;
				_tmp12_ = map_testBox (self, &_tmp10_, &_tmp11_);
				if (_tmp12_) {
					gboolean hit = FALSE;
					Point2d _tmp13_ = {0};
					gdouble _tmp14_ = 0.0;
					Point2d _tmp15_ = {0};
					gdouble _tmp16_ = 0.0;
					Point2d _tmp17_ = {0};
					Vector2d _tmp18_ = {0};
					gboolean _tmp19_ = FALSE;
					Point2d _tmp22_ = {0};
					gdouble _tmp23_ = 0.0;
					Point2d _tmp24_ = {0};
					gdouble _tmp25_ = 0.0;
					Point2d _tmp26_ = {0};
					Vector2d _tmp27_ = {0};
					gboolean _tmp28_ = FALSE;
					gboolean _tmp31_ = FALSE;
					hit = FALSE;
					_tmp13_ = *pos;
					_tmp14_ = _tmp13_.x;
					_tmp15_ = newPos;
					_tmp16_ = _tmp15_.y;
					point2d (_tmp14_, _tmp16_, &_tmp17_);
					_tmp18_ = *size;
					_tmp19_ = map_testBox (self, &_tmp17_, &_tmp18_);
					if (_tmp19_) {
						Point2d _tmp20_ = {0};
						gdouble _tmp21_ = 0.0;
						_result_ = g_list_append (_result_, (gpointer) ((gintptr) COLLISION_y));
						_tmp20_ = *pos;
						_tmp21_ = _tmp20_.y;
						newPos.y = _tmp21_;
						(*vel).y = (gdouble) 0;
						hit = TRUE;
					}
					_tmp22_ = newPos;
					_tmp23_ = _tmp22_.x;
					_tmp24_ = *pos;
					_tmp25_ = _tmp24_.y;
					point2d (_tmp23_, _tmp25_, &_tmp26_);
					_tmp27_ = *size;
					_tmp28_ = map_testBox (self, &_tmp26_, &_tmp27_);
					if (_tmp28_) {
						Point2d _tmp29_ = {0};
						gdouble _tmp30_ = 0.0;
						_result_ = g_list_append (_result_, (gpointer) ((gintptr) COLLISION_x));
						_tmp29_ = *pos;
						_tmp30_ = _tmp29_.x;
						newPos.x = _tmp30_;
						(*vel).x = (gdouble) 0;
						hit = TRUE;
					}
					_tmp31_ = hit;
					if (!_tmp31_) {
						Point2d _tmp32_ = {0};
						Vector2d _tmp33_ = {0};
						_result_ = g_list_append (_result_, (gpointer) ((gintptr) COLLISION_corner));
						_tmp32_ = *pos;
						newPos = _tmp32_;
						vector2d ((gdouble) 0, (gdouble) 0, &_tmp33_);
						*vel = _tmp33_;
					}
				}
				_tmp34_ = newPos;
				*pos = _tmp34_;
			}
		}
	}
	_g_list_free0 (_result_);
}


void map_render (Map* self, SDL_Renderer* renderer, Vector2d* camera) {
	SDL_Rect clip = {0};
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	SDL_Rect _tmp2_ = {0};
	SDL_Rect dest = {0};
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	SDL_Rect _tmp5_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (renderer != NULL);
	g_return_if_fail (camera != NULL);
	_tmp0_ = TILES_SIZE.x;
	_tmp1_ = TILES_SIZE.y;
	rect (0, 0, _tmp0_, _tmp1_, &_tmp2_);
	clip = _tmp2_;
	_tmp3_ = TILES_SIZE.x;
	_tmp4_ = TILES_SIZE.y;
	rect (0, 0, _tmp3_, _tmp4_, &_tmp5_);
	dest = _tmp5_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				GList* _tmp8_ = NULL;
				guint _tmp9_ = 0U;
				gint _tmp10_ = 0;
				gint tileNr = 0;
				GList* _tmp11_ = NULL;
				gint _tmp12_ = 0;
				gconstpointer _tmp13_ = NULL;
				gint _tmp14_ = 0;
				gint _tmp15_ = 0;
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				gint _tmp18_ = 0;
				gint _tmp19_ = 0;
				gint _tmp20_ = 0;
				Vector2d _tmp21_ = {0};
				gdouble _tmp22_ = 0.0;
				gint _tmp23_ = 0;
				gint _tmp24_ = 0;
				gint _tmp25_ = 0;
				Vector2d _tmp26_ = {0};
				gdouble _tmp27_ = 0.0;
				SDL_Renderer* _tmp28_ = NULL;
				SDL_Texture* _tmp29_ = NULL;
				SDL_Rect _tmp30_ = {0};
				SDL_Rect _tmp31_ = {0};
				if (!_tmp6_) {
					gint _tmp7_ = 0;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp8_ = self->tiles;
				_tmp9_ = g_list_length (_tmp8_);
				if (!(i <= (_tmp9_ - 1))) {
					break;
				}
				_tmp10_ = i;
				if (_tmp10_ == 0) {
					continue;
				}
				_tmp11_ = self->tiles;
				_tmp12_ = i;
				_tmp13_ = g_list_nth_data (_tmp11_, (guint) _tmp12_);
				tileNr = (gint) ((guint8) ((guintptr) _tmp13_));
				_tmp14_ = tileNr;
				_tmp15_ = TILES_SIZE.x;
				clip.x = ((gint) (_tmp14_ % TILES_PER_ROW)) * _tmp15_;
				_tmp16_ = tileNr;
				_tmp17_ = TILES_SIZE.y;
				clip.y = ((gint) (_tmp16_ / TILES_PER_ROW)) * _tmp17_;
				_tmp18_ = i;
				_tmp19_ = self->width;
				_tmp20_ = TILES_SIZE.x;
				_tmp21_ = *camera;
				_tmp22_ = _tmp21_.x;
				dest.x = ((_tmp18_ % _tmp19_) * ((gint) _tmp20_)) - ((gint) _tmp22_);
				_tmp23_ = i;
				_tmp24_ = self->width;
				_tmp25_ = TILES_SIZE.y;
				_tmp26_ = *camera;
				_tmp27_ = _tmp26_.y;
				dest.y = (((gint) (_tmp23_ / _tmp24_)) * ((gint) _tmp25_)) - ((gint) _tmp27_);
				_tmp28_ = renderer;
				_tmp29_ = self->texture;
				_tmp30_ = clip;
				_tmp31_ = dest;
				SDL_RenderCopy (_tmp28_, _tmp29_, &_tmp30_, &_tmp31_);
			}
		}
	}
}


static void map_instance_init (Map * self) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar** _tmp11_ = NULL;
	guint8* _tmp12_ = NULL;
	self->retainCount__ = 1;
	_tmp0_ = g_strdup (" 0  0  0  0 78  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  " \
"0  0  0  0  0  0  0  0  0 110  0  0  0  0");
	_tmp1_ = g_strdup (" 4  5  0  0 78  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  " \
"0  0  0  0  0  0  0  0  0 110  0  0  4  5");
	_tmp2_ = g_strdup ("20 21  0  0 78  0  0  0  0  0  0  0  0  0  0  0  0  0  4  5  0  0  0  " \
"0  0  0  0  0  0  0  0  0 110  0  0 20 21");
	_tmp3_ = g_strdup ("20 21  0  0 78  0  0  0  0  0  0  0  0  4  5  0  0  0 36 37  0  0  0  " \
"0  0  0  0  0  0  0  0  0 110  0  0 20 21");
	_tmp4_ = g_strdup ("20 21  0  0 78  0  0  0  0  0  0  0  0 20 21  0  0  0  0  0  0  0  0  " \
"0  0  0  0  0  0  0  0  0 110  0  0 20 21");
	_tmp5_ = g_strdup ("20 21  0  0 78  0  0  0  0  0  0  0  0 20 21  0  0  0  0  0  0  0  4 1" \
"6 16 16 16  5  0  0  0  0 110  0  0 20 21");
	_tmp6_ = g_strdup ("20 21  0  0 78  0  0  4  5  0  0  0  0 20 21  0  0  0  0  0  0  0 36 5" \
"2 54 53 52 37  0  0  0  0 110  0  0 20 21");
	_tmp7_ = g_strdup ("20 21  0  0 78  0  0 20 21  0  0  0  0 20 21  0  0  0  0  0  0  0  0  " \
"0 20 21  0  0  0  0  0  0 110  0  0 20 21");
	_tmp8_ = g_strdup ("20 38  0  0 78  0  0 22 38  0  0  0  0 22 38  0  0  0  0  0  0  0  0  " \
"0 22 38  0  0  0  0  0  0 110  0  0 22 21");
	_tmp9_ = g_strdup ("20 49 16 16 16 16 16 48 49 16 16 16 16 48 49 16 16 16 16 16 16 16 16 1" \
"6 48 49 16 16 16 16 16 16  16 16 16 48 21");
	_tmp10_ = g_strdup ("36 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 52 5" \
"2 52 52 52 52 52 52 52 52  52 52 52 52 37");
	_tmp11_ = g_new0 (gchar*, 11 + 1);
	_tmp11_[0] = _tmp0_;
	_tmp11_[1] = _tmp1_;
	_tmp11_[2] = _tmp2_;
	_tmp11_[3] = _tmp3_;
	_tmp11_[4] = _tmp4_;
	_tmp11_[5] = _tmp5_;
	_tmp11_[6] = _tmp6_;
	_tmp11_[7] = _tmp7_;
	_tmp11_[8] = _tmp8_;
	_tmp11_[9] = _tmp9_;
	_tmp11_[10] = _tmp10_;
	self->lines = _tmp11_;
	self->lines_length1 = 11;
	_tmp12_ = g_new0 (guint8, 4096);
	self->buf = _tmp12_;
	self->buf_length1 = 4096;
}


void map_free (Map* self) {
	self->lines = (_vala_array_free (self->lines, self->lines_length1, (GDestroyNotify) g_free), NULL);
	self->buf = (g_free (self->buf), NULL);
	_g_free0 (self->stat);
	self->ioBuff = (g_free (self->ioBuff), NULL);
	_g_list_free0 (self->tiles);
	g_slice_free (Map, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



