/* Entities.c generated by valac 0.34.8, the Vala compiler
 * generated from Entities.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_render.h>
#include <SDL2/SDL_pixels.h>
#include <SDL2/SDL_surface.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_video.h>


#define TYPE_ENTITY (entity_get_type ())

#define TYPE_CATEGORY (category_get_type ())

#define TYPE_ACTOR (actor_get_type ())

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;

#define TYPE_SPRITE (sprite_get_type ())
typedef struct _Sprite Sprite;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_TIMER (timer_get_type ())
typedef struct _Timer Timer;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;
typedef struct _Entity Entity;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vector2d_free0(var) ((var == NULL) ? NULL : (var = (vector2d_free (var), NULL)))
#define _timer_free0(var) ((var == NULL) ? NULL : (var = (timer_free (var), NULL)))
#define _health_free0(var) ((var == NULL) ? NULL : (var = (health_free (var), NULL)))

#define TYPE_SEGMENT (segment_get_type ())
typedef struct _Segment Segment;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))
#define _SDL_DestroyTexture0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyTexture (var), NULL)))

typedef enum  {
	CATEGORY_BACKGROUND = 0,
	CATEGORY_BULLET = 1,
	CATEGORY_ENEMY = 2,
	CATEGORY_EXPLOSION = 3,
	CATEGORY_PARTICLE = 4,
	CATEGORY_PLAYER = 5
} Category;

typedef enum  {
	ACTOR_DEFAULT = 0,
	ACTOR_BACKGROUND = 1,
	ACTOR_TEXT = 2,
	ACTOR_LIVES = 3,
	ACTOR_ENEMY1 = 4,
	ACTOR_ENEMY2 = 5,
	ACTOR_ENEMY3 = 6,
	ACTOR_PLAYER = 7,
	ACTOR_BULLET = 8,
	ACTOR_EXPLOSION = 9,
	ACTOR_BANG = 10,
	ACTOR_PARTICLE = 11,
	ACTOR_HUD = 12
} Actor;

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Sprite {
	SDL_Texture* texture;
	gint width;
	gint height;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

struct _Timer {
	gint begin;
	gint finish;
	gint best;
};

struct _Health {
	gint curHealth;
	gint maxHealth;
};

struct _Entity {
	gint id;
	gchar* name;
	gboolean active;
	Category category;
	Actor actor;
	Point2d position;
	SDL_Rect bounds;
	Sprite sprite;
	Vector2d* scale;
	SDL_Color* tint;
	Timer* expires;
	Health* health;
	Vector2d* velocity;
};

struct _Segment {
	SDL_Rect source;
	SDL_Rect dest;
	SDL_RendererFlip flip;
};

typedef Segment* (*SpriteBuilder) (gint x, gint y, int* result_length1, void* user_data);


GType entity_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
GType sprite_get_type (void) G_GNUC_CONST;
Sprite* sprite_dup (const Sprite* self);
void sprite_free (Sprite* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
GType timer_get_type (void) G_GNUC_CONST;
Timer* timer_dup (const Timer* self);
void timer_free (Timer* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
static SDL_Color* _sdl_video_color_dup (SDL_Color* self);
void CreatePlayer (SDL_Texture* texture, gint h, gint w, Entity* result);
void point2d (gdouble x, gdouble y, Point2d* result);
void rect (gint x, gint y, gint h, gint w, SDL_Rect* result);
void sprite (SDL_Texture* texture, gint width, gint height, Sprite* result);
void vector2d (gdouble x, gdouble y, Vector2d* result);
SDL_Color color (guint8 r, guint8 g, guint8 b, guint8 a);
void timer (gint begin, gint finish, gint best, Timer* result);
void health (gint curHealth, gint maxHealth, Health* result);
GType segment_get_type (void) G_GNUC_CONST;
Segment* segment_dup (const Segment* self);
void segment_free (Segment* self);
Segment* playerSegments (gint x, gint y, int* result_length1);
void segment (SDL_Rect* source, SDL_Rect* dest, SDL_RendererFlip flip, Segment* result);
SDL_Texture* buildSprite (SDL_Renderer* renderer, SDL_Surface* source, SpriteBuilder builder, void* builder_target, gint h, gint w);
SDL_Texture* loadTexture (SDL_Renderer* renderer, const gchar* path);
void sdlFailIf (gboolean cond, const gchar* reason);


static gpointer _vector2d_dup0 (gpointer self) {
	return self ? vector2d_dup (self) : NULL;
}


static SDL_Color* _sdl_video_color_dup (SDL_Color* self) {
	SDL_Color* dup;
	dup = g_new0 (SDL_Color, 1);
	memcpy (dup, self, sizeof (SDL_Color));
	return dup;
}


static gpointer __sdl_video_color_dup0 (gpointer self) {
	return self ? _sdl_video_color_dup (self) : NULL;
}


static gpointer _timer_dup0 (gpointer self) {
	return self ? timer_dup (self) : NULL;
}


static gpointer _health_dup0 (gpointer self) {
	return self ? health_dup (self) : NULL;
}


void entity_copy (const Entity* self, Entity* dest) {
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	Category _tmp4_ = 0;
	Actor _tmp5_ = 0;
	Point2d _tmp6_ = {0};
	SDL_Rect _tmp7_ = {0};
	Sprite _tmp8_ = {0};
	Vector2d* _tmp9_ = NULL;
	Vector2d* _tmp10_ = NULL;
	SDL_Color* _tmp11_ = NULL;
	SDL_Color* _tmp12_ = NULL;
	Timer* _tmp13_ = NULL;
	Timer* _tmp14_ = NULL;
	Health* _tmp15_ = NULL;
	Health* _tmp16_ = NULL;
	Vector2d* _tmp17_ = NULL;
	Vector2d* _tmp18_ = NULL;
	_tmp0_ = (*self).id;
	(*dest).id = _tmp0_;
	_tmp1_ = (*self).name;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp2_;
	_tmp3_ = (*self).active;
	(*dest).active = _tmp3_;
	_tmp4_ = (*self).category;
	(*dest).category = _tmp4_;
	_tmp5_ = (*self).actor;
	(*dest).actor = _tmp5_;
	_tmp6_ = (*self).position;
	(*dest).position = _tmp6_;
	_tmp7_ = (*self).bounds;
	(*dest).bounds = _tmp7_;
	_tmp8_ = (*self).sprite;
	(*dest).sprite = _tmp8_;
	_tmp9_ = (*self).scale;
	_tmp10_ = _vector2d_dup0 (_tmp9_);
	_vector2d_free0 ((*dest).scale);
	(*dest).scale = _tmp10_;
	_tmp11_ = (*self).tint;
	_tmp12_ = __sdl_video_color_dup0 (_tmp11_);
	_g_free0 ((*dest).tint);
	(*dest).tint = _tmp12_;
	_tmp13_ = (*self).expires;
	_tmp14_ = _timer_dup0 (_tmp13_);
	_timer_free0 ((*dest).expires);
	(*dest).expires = _tmp14_;
	_tmp15_ = (*self).health;
	_tmp16_ = _health_dup0 (_tmp15_);
	_health_free0 ((*dest).health);
	(*dest).health = _tmp16_;
	_tmp17_ = (*self).velocity;
	_tmp18_ = _vector2d_dup0 (_tmp17_);
	_vector2d_free0 ((*dest).velocity);
	(*dest).velocity = _tmp18_;
}


void entity_destroy (Entity* self) {
	_g_free0 ((*self).name);
	_vector2d_free0 ((*self).scale);
	_g_free0 ((*self).tint);
	_timer_free0 ((*self).expires);
	_health_free0 ((*self).health);
	_vector2d_free0 ((*self).velocity);
}


Entity* entity_dup (const Entity* self) {
	Entity* dup;
	dup = g_new0 (Entity, 1);
	entity_copy (self, dup);
	return dup;
}


void entity_free (Entity* self) {
	entity_destroy (self);
	g_free (self);
}


GType entity_get_type (void) {
	static volatile gsize entity_type_id__volatile = 0;
	if (g_once_init_enter (&entity_type_id__volatile)) {
		GType entity_type_id;
		entity_type_id = g_boxed_type_register_static ("Entity", (GBoxedCopyFunc) entity_dup, (GBoxedFreeFunc) entity_free);
		g_once_init_leave (&entity_type_id__volatile, entity_type_id);
	}
	return entity_type_id__volatile;
}


void CreatePlayer (SDL_Texture* texture, gint h, gint w, Entity* result) {
	gchar* _tmp0_ = NULL;
	Point2d _tmp1_ = {0};
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	SDL_Rect _tmp4_ = {0};
	SDL_Texture* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	Sprite _tmp8_ = {0};
	Vector2d _tmp9_ = {0};
	Vector2d* _tmp10_ = NULL;
	SDL_Color _tmp11_ = {0};
	SDL_Color* _tmp12_ = NULL;
	Timer _tmp13_ = {0};
	Timer* _tmp14_ = NULL;
	Health _tmp15_ = {0};
	Health* _tmp16_ = NULL;
	Vector2d _tmp17_ = {0};
	Vector2d* _tmp18_ = NULL;
	Entity _tmp19_ = {0};
	g_return_if_fail (texture != NULL);
	_tmp0_ = g_strdup ("Player");
	point2d ((gdouble) 170, (gdouble) 500, &_tmp1_);
	_tmp2_ = h;
	_tmp3_ = w;
	rect (0, 0, _tmp2_, _tmp3_, &_tmp4_);
	_tmp5_ = texture;
	_tmp6_ = h;
	_tmp7_ = w;
	sprite (_tmp5_, _tmp6_, _tmp7_, &_tmp8_);
	vector2d ((gdouble) 1, (gdouble) 1, &_tmp9_);
	_tmp10_ = _vector2d_dup0 (&_tmp9_);
	_tmp11_ = color ((guint8) 0, (guint8) 0, (guint8) 0, (guint8) 255);
	_tmp12_ = __sdl_video_color_dup0 (&_tmp11_);
	timer (-1, -1, -1, &_tmp13_);
	_tmp14_ = _timer_dup0 (&_tmp13_);
	health (0, 0, &_tmp15_);
	_tmp16_ = _health_dup0 (&_tmp15_);
	vector2d ((gdouble) 0, (gdouble) 0, &_tmp17_);
	_tmp18_ = _vector2d_dup0 (&_tmp17_);
	memset (&_tmp19_, 0, sizeof (Entity));
	_tmp19_.id = 0;
	_g_free0 (_tmp19_.name);
	_tmp19_.name = _tmp0_;
	_tmp19_.active = TRUE;
	_tmp19_.category = CATEGORY_PLAYER;
	_tmp19_.actor = ACTOR_PLAYER;
	_tmp19_.position = _tmp1_;
	_tmp19_.bounds = _tmp4_;
	_tmp19_.sprite = _tmp8_;
	_vector2d_free0 (_tmp19_.scale);
	_tmp19_.scale = _tmp10_;
	_g_free0 (_tmp19_.tint);
	_tmp19_.tint = _tmp12_;
	_timer_free0 (_tmp19_.expires);
	_tmp19_.expires = _tmp14_;
	_health_free0 (_tmp19_.health);
	_tmp19_.health = _tmp16_;
	_vector2d_free0 (_tmp19_.velocity);
	_tmp19_.velocity = _tmp18_;
	*result = _tmp19_;
	return;
}


Segment* playerSegments (gint x, gint y, int* result_length1) {
	Segment* result = NULL;
	SDL_Rect _tmp0_ = {0};
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	SDL_Rect _tmp3_ = {0};
	Segment _tmp4_ = {0};
	SDL_Rect _tmp5_ = {0};
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	SDL_Rect _tmp8_ = {0};
	Segment _tmp9_ = {0};
	SDL_Rect _tmp10_ = {0};
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	SDL_Rect _tmp13_ = {0};
	Segment _tmp14_ = {0};
	SDL_Rect _tmp15_ = {0};
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	SDL_Rect _tmp18_ = {0};
	Segment _tmp19_ = {0};
	SDL_Rect _tmp20_ = {0};
	gint _tmp21_ = 0;
	gint _tmp22_ = 0;
	SDL_Rect _tmp23_ = {0};
	Segment _tmp24_ = {0};
	SDL_Rect _tmp25_ = {0};
	gint _tmp26_ = 0;
	gint _tmp27_ = 0;
	SDL_Rect _tmp28_ = {0};
	Segment _tmp29_ = {0};
	SDL_Rect _tmp30_ = {0};
	gint _tmp31_ = 0;
	gint _tmp32_ = 0;
	SDL_Rect _tmp33_ = {0};
	Segment _tmp34_ = {0};
	SDL_Rect _tmp35_ = {0};
	gint _tmp36_ = 0;
	gint _tmp37_ = 0;
	SDL_Rect _tmp38_ = {0};
	Segment _tmp39_ = {0};
	Segment* _tmp40_ = NULL;
	Segment* _tmp41_ = NULL;
	gint _tmp41__length1 = 0;
	rect (192, 64, 64, 32, &_tmp0_);
	_tmp1_ = x;
	_tmp2_ = y;
	rect (_tmp1_ - 60, _tmp2_, 96, 48, &_tmp3_);
	segment (&_tmp0_, &_tmp3_, SDL_FLIP_NONE, &_tmp4_);
	rect (96, 0, 96, 96, &_tmp5_);
	_tmp6_ = x;
	_tmp7_ = y;
	rect (_tmp6_ - 48, _tmp7_ - 48, 96, 96, &_tmp8_);
	segment (&_tmp5_, &_tmp8_, SDL_FLIP_NONE, &_tmp9_);
	rect (192, 64, 64, 32, &_tmp10_);
	_tmp11_ = x;
	_tmp12_ = y;
	rect (_tmp11_ - 36, _tmp12_, 96, 48, &_tmp13_);
	segment (&_tmp10_, &_tmp13_, SDL_FLIP_NONE, &_tmp14_);
	rect (192, 32, 64, 32, &_tmp15_);
	_tmp16_ = x;
	_tmp17_ = y;
	rect (_tmp16_ - 60, _tmp17_, 96, 48, &_tmp18_);
	segment (&_tmp15_, &_tmp18_, SDL_FLIP_NONE, &_tmp19_);
	rect (0, 0, 96, 96, &_tmp20_);
	_tmp21_ = x;
	_tmp22_ = y;
	rect (_tmp21_ - 48, _tmp22_ - 48, 96, 96, &_tmp23_);
	segment (&_tmp20_, &_tmp23_, SDL_FLIP_NONE, &_tmp24_);
	rect (192, 32, 64, 32, &_tmp25_);
	_tmp26_ = x;
	_tmp27_ = y;
	rect (_tmp26_ - 36, _tmp27_, 96, 48, &_tmp28_);
	segment (&_tmp25_, &_tmp28_, SDL_FLIP_NONE, &_tmp29_);
	rect (64, 96, 32, 32, &_tmp30_);
	_tmp31_ = x;
	_tmp32_ = y;
	rect (_tmp31_ - 18, _tmp32_ - 21, 36, 36, &_tmp33_);
	segment (&_tmp30_, &_tmp33_, SDL_FLIP_NONE, &_tmp34_);
	rect (64, 96, 32, 32, &_tmp35_);
	_tmp36_ = x;
	_tmp37_ = y;
	rect (_tmp36_ - 6, _tmp37_ - 21, 36, 36, &_tmp38_);
	segment (&_tmp35_, &_tmp38_, SDL_FLIP_HORIZONTAL, &_tmp39_);
	_tmp40_ = g_new0 (Segment, 8);
	_tmp40_[0] = _tmp4_;
	_tmp40_[1] = _tmp9_;
	_tmp40_[2] = _tmp14_;
	_tmp40_[3] = _tmp19_;
	_tmp40_[4] = _tmp24_;
	_tmp40_[5] = _tmp29_;
	_tmp40_[6] = _tmp34_;
	_tmp40_[7] = _tmp39_;
	_tmp41_ = _tmp40_;
	_tmp41__length1 = 8;
	if (result_length1) {
		*result_length1 = _tmp41__length1;
	}
	result = _tmp41_;
	return result;
}


SDL_Texture* buildSprite (SDL_Renderer* renderer, SDL_Surface* source, SpriteBuilder builder, void* builder_target, gint h, gint w) {
	SDL_Texture* result = NULL;
	guint32 flags = 0U;
	guint32 rmask = 0U;
	guint32 gmask = 0U;
	guint32 bmask = 0U;
	guint32 amask = 0U;
	SDL_Surface* surface = NULL;
	guint32 _tmp0_ = 0U;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	guint32 _tmp3_ = 0U;
	guint32 _tmp4_ = 0U;
	guint32 _tmp5_ = 0U;
	guint32 _tmp6_ = 0U;
	SDL_Surface* _tmp7_ = NULL;
	SpriteBuilder _tmp8_ = NULL;
	void* _tmp8__target = NULL;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	Segment* _tmp12_ = NULL;
	SDL_Texture* texture = NULL;
	SDL_Renderer* _tmp19_ = NULL;
	SDL_Surface* _tmp20_ = NULL;
	SDL_Texture* _tmp21_ = NULL;
	g_return_val_if_fail (renderer != NULL, NULL);
	g_return_val_if_fail (source != NULL, NULL);
	flags = (guint32) 0x00010000;
	rmask = (guint32) 0x000000ff;
	gmask = (guint32) 0x0000ff00;
	bmask = (guint32) 0x00ff0000;
	amask = (guint32) 0xff000000LL;
	_tmp0_ = flags;
	_tmp1_ = h;
	_tmp2_ = w;
	_tmp3_ = rmask;
	_tmp4_ = gmask;
	_tmp5_ = bmask;
	_tmp6_ = amask;
	_tmp7_ = SDL_CreateRGBSurface (_tmp0_, _tmp1_, _tmp2_, 32, _tmp3_, _tmp4_, _tmp5_, _tmp6_);
	surface = _tmp7_;
	_tmp8_ = builder;
	_tmp8__target = builder_target;
	_tmp9_ = h;
	_tmp10_ = w;
	_tmp12_ = _tmp8_ (_tmp9_ / 2, _tmp10_ / 2, &_tmp11_, _tmp8__target);
	{
		Segment* segment_collection = NULL;
		gint segment_collection_length1 = 0;
		gint _segment_collection_size_ = 0;
		gint segment_it = 0;
		segment_collection = _tmp12_;
		segment_collection_length1 = _tmp11_;
		for (segment_it = 0; segment_it < _tmp11_; segment_it = segment_it + 1) {
			Segment segment = {0};
			segment = segment_collection[segment_it];
			{
				SDL_Surface* _tmp13_ = NULL;
				Segment _tmp14_ = {0};
				SDL_Rect _tmp15_ = {0};
				SDL_Surface* _tmp16_ = NULL;
				Segment _tmp17_ = {0};
				SDL_Rect _tmp18_ = {0};
				_tmp13_ = source;
				_tmp14_ = segment;
				_tmp15_ = _tmp14_.source;
				_tmp16_ = surface;
				_tmp17_ = segment;
				_tmp18_ = _tmp17_.dest;
				SDL_BlitScaled (_tmp13_, &_tmp15_, _tmp16_, &_tmp18_);
			}
		}
		segment_collection = (g_free (segment_collection), NULL);
	}
	_tmp19_ = renderer;
	_tmp20_ = surface;
	_tmp21_ = SDL_CreateTextureFromSurface (_tmp19_, _tmp20_);
	texture = _tmp21_;
	result = texture;
	_SDL_FreeSurface0 (surface);
	return result;
}


SDL_Texture* loadTexture (SDL_Renderer* renderer, const gchar* path) {
	SDL_Texture* result = NULL;
	SDL_Surface* surface = NULL;
	const gchar* _tmp0_ = NULL;
	SDL_Surface* _tmp1_ = NULL;
	SDL_Texture* texture = NULL;
	SDL_Renderer* _tmp2_ = NULL;
	SDL_Texture* _tmp3_ = NULL;
	g_return_val_if_fail (renderer != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	_tmp0_ = path;
	_tmp1_ = IMG_Load (_tmp0_);
	surface = _tmp1_;
	sdlFailIf (surface == NULL, "Unable to load image!");
	_tmp2_ = renderer;
	_tmp3_ = SDL_CreateTextureFromSurface (_tmp2_, surface);
	texture = _tmp3_;
	sdlFailIf (texture == NULL, "Unable to load texture!");
	SDL_SetTextureBlendMode (texture, SDL_BLENDMODE_BLEND);
	result = texture;
	_SDL_FreeSurface0 (surface);
	return result;
}



