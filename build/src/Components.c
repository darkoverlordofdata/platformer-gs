/* Components.c generated by valac 0.34.8, the Vala compiler
 * generated from Components.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_render.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <SDL2/SDL_pixels.h>


#define TYPE_INPUT (input_get_type ())

#define TYPE_COLLISION (collision_get_type ())

#define TYPE_CAMERA_TYPE (camera_type_get_type ())

#define TYPE_ACTOR (actor_get_type ())

#define TYPE_CATEGORY (category_get_type ())

#define TYPE_SEGMENT (segment_get_type ())
typedef struct _Segment Segment;

#define TYPE_TIMER (timer_get_type ())
typedef struct _Timer Timer;

#define TYPE_SCALE_TWEEN (scale_tween_get_type ())
typedef struct _ScaleTween ScaleTween;

#define TYPE_SPRITE (sprite_get_type ())
typedef struct _Sprite Sprite;

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;

typedef enum  {
	INPUT_none,
	INPUT_left,
	INPUT_right,
	INPUT_jump,
	INPUT_restart,
	INPUT_quit
} Input;

typedef enum  {
	COLLISION_x,
	COLLISION_y,
	COLLISION_corner
} Collision;

typedef enum  {
	CAMERA_TYPE_fluidCamera,
	CAMERA_TYPE_innerCamera,
	CAMERA_TYPE_simpleCamera
} CameraType;

typedef enum  {
	ACTOR_DEFAULT = 0,
	ACTOR_BACKGROUND = 1,
	ACTOR_TEXT = 2,
	ACTOR_LIVES = 3,
	ACTOR_ENEMY1 = 4,
	ACTOR_ENEMY2 = 5,
	ACTOR_ENEMY3 = 6,
	ACTOR_PLAYER = 7,
	ACTOR_BULLET = 8,
	ACTOR_EXPLOSION = 9,
	ACTOR_BANG = 10,
	ACTOR_PARTICLE = 11,
	ACTOR_HUD = 12
} Actor;

typedef enum  {
	CATEGORY_BACKGROUND = 0,
	CATEGORY_BULLET = 1,
	CATEGORY_ENEMY = 2,
	CATEGORY_EXPLOSION = 3,
	CATEGORY_PARTICLE = 4,
	CATEGORY_PLAYER = 5
} Category;

struct _Segment {
	SDL_Rect source;
	SDL_Rect dest;
	SDL_RendererFlip flip;
};

struct _Timer {
	gint begin;
	gint finish;
	gint best;
};

struct _ScaleTween {
	gdouble min;
	gdouble max;
	gdouble speed;
	gboolean repeat;
	gboolean active;
};

struct _Sprite {
	SDL_Texture* texture;
	gint width;
	gint height;
};

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

struct _Health {
	gint curHealth;
	gint maxHealth;
};



GType input_get_type (void) G_GNUC_CONST;
GType collision_get_type (void) G_GNUC_CONST;
GType camera_type_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
GType segment_get_type (void) G_GNUC_CONST;
Segment* segment_dup (const Segment* self);
void segment_free (Segment* self);
GType timer_get_type (void) G_GNUC_CONST;
Timer* timer_dup (const Timer* self);
void timer_free (Timer* self);
GType scale_tween_get_type (void) G_GNUC_CONST;
ScaleTween* scale_tween_dup (const ScaleTween* self);
void scale_tween_free (ScaleTween* self);
GType sprite_get_type (void) G_GNUC_CONST;
Sprite* sprite_dup (const Sprite* self);
void sprite_free (Sprite* self);
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
void point2d_add (Point2d *self, Vector2d* v, Point2d* result);
void point2d (gdouble x, gdouble y, Point2d* result);
void point2d_sub (Point2d *self, Vector2d* v, Point2d* result);
void vector2d_mul (Vector2d *self, gdouble f, Vector2d* result);
void vector2d (gdouble x, gdouble y, Vector2d* result);
void vector2d_div (Vector2d *self, gdouble f, Vector2d* result);
gdouble vector2d_len (Vector2d *self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
void sprite (SDL_Texture* texture, gint width, gint height, Sprite* result);
void timer (gint begin, gint finish, gint best, Timer* result);
void rect (gint x, gint y, gint h, gint w, SDL_Rect* result);
SDL_Color color (guint8 r, guint8 g, guint8 b, guint8 a);
void segment (SDL_Rect* source, SDL_Rect* dest, SDL_RendererFlip flip, Segment* result);
void health (gint curHealth, gint maxHealth, Health* result);
void scaletween (gdouble min, gdouble max, gdouble speed, gboolean repeat, gboolean active, ScaleTween* result);


GType input_get_type (void) {
	static volatile gsize input_type_id__volatile = 0;
	if (g_once_init_enter (&input_type_id__volatile)) {
		static const GEnumValue values[] = {{INPUT_none, "INPUT_none", "none"}, {INPUT_left, "INPUT_left", "left"}, {INPUT_right, "INPUT_right", "right"}, {INPUT_jump, "INPUT_jump", "jump"}, {INPUT_restart, "INPUT_restart", "restart"}, {INPUT_quit, "INPUT_quit", "quit"}, {0, NULL, NULL}};
		GType input_type_id;
		input_type_id = g_enum_register_static ("Input", values);
		g_once_init_leave (&input_type_id__volatile, input_type_id);
	}
	return input_type_id__volatile;
}


GType collision_get_type (void) {
	static volatile gsize collision_type_id__volatile = 0;
	if (g_once_init_enter (&collision_type_id__volatile)) {
		static const GEnumValue values[] = {{COLLISION_x, "COLLISION_x", "x"}, {COLLISION_y, "COLLISION_y", "y"}, {COLLISION_corner, "COLLISION_corner", "corner"}, {0, NULL, NULL}};
		GType collision_type_id;
		collision_type_id = g_enum_register_static ("Collision", values);
		g_once_init_leave (&collision_type_id__volatile, collision_type_id);
	}
	return collision_type_id__volatile;
}


GType camera_type_get_type (void) {
	static volatile gsize camera_type_type_id__volatile = 0;
	if (g_once_init_enter (&camera_type_type_id__volatile)) {
		static const GEnumValue values[] = {{CAMERA_TYPE_fluidCamera, "CAMERA_TYPE_fluidCamera", "fluidcamera"}, {CAMERA_TYPE_innerCamera, "CAMERA_TYPE_innerCamera", "innercamera"}, {CAMERA_TYPE_simpleCamera, "CAMERA_TYPE_simpleCamera", "simplecamera"}, {0, NULL, NULL}};
		GType camera_type_type_id;
		camera_type_type_id = g_enum_register_static ("CameraType", values);
		g_once_init_leave (&camera_type_type_id__volatile, camera_type_type_id);
	}
	return camera_type_type_id__volatile;
}


GType actor_get_type (void) {
	static volatile gsize actor_type_id__volatile = 0;
	if (g_once_init_enter (&actor_type_id__volatile)) {
		static const GEnumValue values[] = {{ACTOR_DEFAULT, "ACTOR_DEFAULT", "default"}, {ACTOR_BACKGROUND, "ACTOR_BACKGROUND", "background"}, {ACTOR_TEXT, "ACTOR_TEXT", "text"}, {ACTOR_LIVES, "ACTOR_LIVES", "lives"}, {ACTOR_ENEMY1, "ACTOR_ENEMY1", "enemy1"}, {ACTOR_ENEMY2, "ACTOR_ENEMY2", "enemy2"}, {ACTOR_ENEMY3, "ACTOR_ENEMY3", "enemy3"}, {ACTOR_PLAYER, "ACTOR_PLAYER", "player"}, {ACTOR_BULLET, "ACTOR_BULLET", "bullet"}, {ACTOR_EXPLOSION, "ACTOR_EXPLOSION", "explosion"}, {ACTOR_BANG, "ACTOR_BANG", "bang"}, {ACTOR_PARTICLE, "ACTOR_PARTICLE", "particle"}, {ACTOR_HUD, "ACTOR_HUD", "hud"}, {0, NULL, NULL}};
		GType actor_type_id;
		actor_type_id = g_enum_register_static ("Actor", values);
		g_once_init_leave (&actor_type_id__volatile, actor_type_id);
	}
	return actor_type_id__volatile;
}


GType category_get_type (void) {
	static volatile gsize category_type_id__volatile = 0;
	if (g_once_init_enter (&category_type_id__volatile)) {
		static const GEnumValue values[] = {{CATEGORY_BACKGROUND, "CATEGORY_BACKGROUND", "background"}, {CATEGORY_BULLET, "CATEGORY_BULLET", "bullet"}, {CATEGORY_ENEMY, "CATEGORY_ENEMY", "enemy"}, {CATEGORY_EXPLOSION, "CATEGORY_EXPLOSION", "explosion"}, {CATEGORY_PARTICLE, "CATEGORY_PARTICLE", "particle"}, {CATEGORY_PLAYER, "CATEGORY_PLAYER", "player"}, {0, NULL, NULL}};
		GType category_type_id;
		category_type_id = g_enum_register_static ("Category", values);
		g_once_init_leave (&category_type_id__volatile, category_type_id);
	}
	return category_type_id__volatile;
}


Segment* segment_dup (const Segment* self) {
	Segment* dup;
	dup = g_new0 (Segment, 1);
	memcpy (dup, self, sizeof (Segment));
	return dup;
}


void segment_free (Segment* self) {
	g_free (self);
}


GType segment_get_type (void) {
	static volatile gsize segment_type_id__volatile = 0;
	if (g_once_init_enter (&segment_type_id__volatile)) {
		GType segment_type_id;
		segment_type_id = g_boxed_type_register_static ("Segment", (GBoxedCopyFunc) segment_dup, (GBoxedFreeFunc) segment_free);
		g_once_init_leave (&segment_type_id__volatile, segment_type_id);
	}
	return segment_type_id__volatile;
}


Timer* timer_dup (const Timer* self) {
	Timer* dup;
	dup = g_new0 (Timer, 1);
	memcpy (dup, self, sizeof (Timer));
	return dup;
}


void timer_free (Timer* self) {
	g_free (self);
}


GType timer_get_type (void) {
	static volatile gsize timer_type_id__volatile = 0;
	if (g_once_init_enter (&timer_type_id__volatile)) {
		GType timer_type_id;
		timer_type_id = g_boxed_type_register_static ("Timer", (GBoxedCopyFunc) timer_dup, (GBoxedFreeFunc) timer_free);
		g_once_init_leave (&timer_type_id__volatile, timer_type_id);
	}
	return timer_type_id__volatile;
}


ScaleTween* scale_tween_dup (const ScaleTween* self) {
	ScaleTween* dup;
	dup = g_new0 (ScaleTween, 1);
	memcpy (dup, self, sizeof (ScaleTween));
	return dup;
}


void scale_tween_free (ScaleTween* self) {
	g_free (self);
}


GType scale_tween_get_type (void) {
	static volatile gsize scale_tween_type_id__volatile = 0;
	if (g_once_init_enter (&scale_tween_type_id__volatile)) {
		GType scale_tween_type_id;
		scale_tween_type_id = g_boxed_type_register_static ("ScaleTween", (GBoxedCopyFunc) scale_tween_dup, (GBoxedFreeFunc) scale_tween_free);
		g_once_init_leave (&scale_tween_type_id__volatile, scale_tween_type_id);
	}
	return scale_tween_type_id__volatile;
}


Sprite* sprite_dup (const Sprite* self) {
	Sprite* dup;
	dup = g_new0 (Sprite, 1);
	memcpy (dup, self, sizeof (Sprite));
	return dup;
}


void sprite_free (Sprite* self) {
	g_free (self);
}


GType sprite_get_type (void) {
	static volatile gsize sprite_type_id__volatile = 0;
	if (g_once_init_enter (&sprite_type_id__volatile)) {
		GType sprite_type_id;
		sprite_type_id = g_boxed_type_register_static ("Sprite", (GBoxedCopyFunc) sprite_dup, (GBoxedFreeFunc) sprite_free);
		g_once_init_leave (&sprite_type_id__volatile, sprite_type_id);
	}
	return sprite_type_id__volatile;
}


inline void point2d_add (Point2d *self, Vector2d* v, Point2d* result) {
	gdouble _tmp0_ = 0.0;
	Vector2d _tmp1_ = {0};
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	Point2d _tmp6_ = {0};
	g_return_if_fail (v != NULL);
	_tmp0_ = (*self).x;
	_tmp1_ = *v;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = (*self).y;
	_tmp4_ = *v;
	_tmp5_ = _tmp4_.y;
	point2d (_tmp0_ + _tmp2_, _tmp3_ + _tmp5_, &_tmp6_);
	*result = _tmp6_;
	return;
}


inline void point2d_sub (Point2d *self, Vector2d* v, Point2d* result) {
	gdouble _tmp0_ = 0.0;
	Vector2d _tmp1_ = {0};
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	Point2d _tmp6_ = {0};
	g_return_if_fail (v != NULL);
	_tmp0_ = (*self).x;
	_tmp1_ = *v;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = (*self).y;
	_tmp4_ = *v;
	_tmp5_ = _tmp4_.y;
	point2d (_tmp0_ - _tmp2_, _tmp3_ - _tmp5_, &_tmp6_);
	*result = _tmp6_;
	return;
}


Point2d* point2d_dup (const Point2d* self) {
	Point2d* dup;
	dup = g_new0 (Point2d, 1);
	memcpy (dup, self, sizeof (Point2d));
	return dup;
}


void point2d_free (Point2d* self) {
	g_free (self);
}


GType point2d_get_type (void) {
	static volatile gsize point2d_type_id__volatile = 0;
	if (g_once_init_enter (&point2d_type_id__volatile)) {
		GType point2d_type_id;
		point2d_type_id = g_boxed_type_register_static ("Point2d", (GBoxedCopyFunc) point2d_dup, (GBoxedFreeFunc) point2d_free);
		g_once_init_leave (&point2d_type_id__volatile, point2d_type_id);
	}
	return point2d_type_id__volatile;
}


inline void vector2d_mul (Vector2d *self, gdouble f, Vector2d* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	_tmp0_ = (*self).x;
	_tmp1_ = f;
	_tmp2_ = (*self).y;
	_tmp3_ = f;
	vector2d (_tmp0_ * _tmp1_, _tmp2_ * _tmp3_, &_tmp4_);
	*result = _tmp4_;
	return;
}


inline void vector2d_div (Vector2d *self, gdouble f, Vector2d* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	_tmp0_ = (*self).x;
	_tmp1_ = f;
	_tmp2_ = (*self).y;
	_tmp3_ = f;
	vector2d (_tmp0_ / _tmp1_, _tmp2_ / _tmp3_, &_tmp4_);
	*result = _tmp4_;
	return;
}


inline gdouble vector2d_len (Vector2d *self) {
	gdouble result = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	_tmp0_ = (*self).x;
	_tmp1_ = (*self).x;
	_tmp2_ = (*self).y;
	_tmp3_ = (*self).y;
	_tmp4_ = sqrt ((_tmp0_ * _tmp1_) + (_tmp2_ * _tmp3_));
	result = _tmp4_;
	return result;
}


Vector2d* vector2d_dup (const Vector2d* self) {
	Vector2d* dup;
	dup = g_new0 (Vector2d, 1);
	memcpy (dup, self, sizeof (Vector2d));
	return dup;
}


void vector2d_free (Vector2d* self) {
	g_free (self);
}


GType vector2d_get_type (void) {
	static volatile gsize vector2d_type_id__volatile = 0;
	if (g_once_init_enter (&vector2d_type_id__volatile)) {
		GType vector2d_type_id;
		vector2d_type_id = g_boxed_type_register_static ("Vector2d", (GBoxedCopyFunc) vector2d_dup, (GBoxedFreeFunc) vector2d_free);
		g_once_init_leave (&vector2d_type_id__volatile, vector2d_type_id);
	}
	return vector2d_type_id__volatile;
}


Health* health_dup (const Health* self) {
	Health* dup;
	dup = g_new0 (Health, 1);
	memcpy (dup, self, sizeof (Health));
	return dup;
}


void health_free (Health* self) {
	g_free (self);
}


GType health_get_type (void) {
	static volatile gsize health_type_id__volatile = 0;
	if (g_once_init_enter (&health_type_id__volatile)) {
		GType health_type_id;
		health_type_id = g_boxed_type_register_static ("Health", (GBoxedCopyFunc) health_dup, (GBoxedFreeFunc) health_free);
		g_once_init_leave (&health_type_id__volatile, health_type_id);
	}
	return health_type_id__volatile;
}


void sprite (SDL_Texture* texture, gint width, gint height, Sprite* result) {
	Sprite sprite = {0};
	SDL_Texture* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	Sprite _tmp3_ = {0};
	g_return_if_fail (texture != NULL);
	_tmp0_ = texture;
	_tmp1_ = width;
	_tmp2_ = height;
	_tmp3_.texture = _tmp0_;
	_tmp3_.width = _tmp1_;
	_tmp3_.height = _tmp2_;
	sprite = _tmp3_;
	*result = sprite;
	return;
}


void timer (gint begin, gint finish, gint best, Timer* result) {
	Timer timer = {0};
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	Timer _tmp3_ = {0};
	_tmp0_ = begin;
	_tmp1_ = finish;
	_tmp2_ = best;
	_tmp3_.begin = _tmp0_;
	_tmp3_.finish = _tmp1_;
	_tmp3_.best = _tmp2_;
	timer = _tmp3_;
	*result = timer;
	return;
}


void rect (gint x, gint y, gint h, gint w, SDL_Rect* result) {
	SDL_Rect rect = {0};
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	SDL_Rect _tmp4_ = {0};
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_ = h;
	_tmp3_ = w;
	_tmp4_.x = _tmp0_;
	_tmp4_.y = _tmp1_;
	_tmp4_.w = (guint) _tmp2_;
	_tmp4_.h = (guint) _tmp3_;
	rect = _tmp4_;
	*result = rect;
	return;
}


void point2d (gdouble x, gdouble y, Point2d* result) {
	Point2d point2d = {0};
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	Point2d _tmp2_ = {0};
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_.x = _tmp0_;
	_tmp2_.y = _tmp1_;
	point2d = _tmp2_;
	*result = point2d;
	return;
}


void vector2d (gdouble x, gdouble y, Vector2d* result) {
	Vector2d vector2d = {0};
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	Vector2d _tmp2_ = {0};
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_.x = _tmp0_;
	_tmp2_.y = _tmp1_;
	vector2d = _tmp2_;
	*result = vector2d;
	return;
}


SDL_Color color (guint8 r, guint8 g, guint8 b, guint8 a) {
	SDL_Color result = {0};
	SDL_Color color = {0};
	guint8 _tmp0_ = 0U;
	guint8 _tmp1_ = 0U;
	guint8 _tmp2_ = 0U;
	guint8 _tmp3_ = 0U;
	SDL_Color _tmp4_ = {0};
	_tmp0_ = r;
	_tmp1_ = g;
	_tmp2_ = b;
	_tmp3_ = a;
	_tmp4_.r = _tmp0_;
	_tmp4_.g = _tmp1_;
	_tmp4_.b = _tmp2_;
	_tmp4_.a = _tmp3_;
	color = _tmp4_;
	result = color;
	return result;
}


void segment (SDL_Rect* source, SDL_Rect* dest, SDL_RendererFlip flip, Segment* result) {
	Segment segment = {0};
	SDL_Rect _tmp0_ = {0};
	SDL_Rect _tmp1_ = {0};
	SDL_RendererFlip _tmp2_ = 0;
	Segment _tmp3_ = {0};
	g_return_if_fail (source != NULL);
	g_return_if_fail (dest != NULL);
	_tmp0_ = *source;
	_tmp1_ = *dest;
	_tmp2_ = flip;
	_tmp3_.source = _tmp0_;
	_tmp3_.dest = _tmp1_;
	_tmp3_.flip = _tmp2_;
	segment = _tmp3_;
	*result = segment;
	return;
}


void health (gint curHealth, gint maxHealth, Health* result) {
	Health health = {0};
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	Health _tmp2_ = {0};
	_tmp0_ = curHealth;
	_tmp1_ = maxHealth;
	_tmp2_.curHealth = _tmp0_;
	_tmp2_.maxHealth = _tmp1_;
	health = _tmp2_;
	*result = health;
	return;
}


void scaletween (gdouble min, gdouble max, gdouble speed, gboolean repeat, gboolean active, ScaleTween* result) {
	ScaleTween scaletween = {0};
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	ScaleTween _tmp5_ = {0};
	_tmp0_ = min;
	_tmp1_ = max;
	_tmp2_ = speed;
	_tmp3_ = repeat;
	_tmp4_ = active;
	_tmp5_.min = _tmp0_;
	_tmp5_.max = _tmp1_;
	_tmp5_.speed = _tmp2_;
	_tmp5_.repeat = _tmp3_;
	_tmp5_.active = _tmp4_;
	scaletween = _tmp5_;
	*result = scaletween;
	return;
}



