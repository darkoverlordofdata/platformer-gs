/* Components.c generated by valac 0.34.8, the Vala compiler
 * generated from Components.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_pixels.h>
#include <SDL2/SDL_render.h>


#define TYPE_COLLISION (collision_get_type ())

#define TYPE_ACTOR (actor_get_type ())

#define TYPE_CATEGORY (category_get_type ())

#define TYPE_ENTITY (entity_get_type ())

#define TYPE_POINT2D (point2d_get_type ())
typedef struct _Point2d Point2d;
typedef struct _sdxgraphicsSprite sdxgraphicsSprite;

#define TYPE_VECTOR2D (vector2d_get_type ())
typedef struct _Vector2d Vector2d;

#define TYPE_TIMER (timer_get_type ())
typedef struct _Timer Timer;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;
typedef struct _Entity Entity;
#define _g_free0(var) (var = (g_free (var), NULL))
void sdx_graphics_sprite_release (sdxgraphicsSprite* self);
void sdx_graphics_sprite_free (sdxgraphicsSprite* self);
sdxgraphicsSprite* sdx_graphics_sprite_retain (sdxgraphicsSprite* self);
#define _sdx_graphics_sprite_release0(var) ((var == NULL) ? NULL : (var = (sdx_graphics_sprite_release (var), NULL)))
#define _vector2d_free0(var) ((var == NULL) ? NULL : (var = (vector2d_free (var), NULL)))
#define _timer_free0(var) ((var == NULL) ? NULL : (var = (timer_free (var), NULL)))
#define _health_free0(var) ((var == NULL) ? NULL : (var = (health_free (var), NULL)))

#define TYPE_BLIT (blit_get_type ())
typedef struct _Blit Blit;

#define TYPE_SCALE_TWEEN (scale_tween_get_type ())
typedef struct _ScaleTween ScaleTween;

#define TYPE_SPRITE (sprite_get_type ())
typedef struct _Sprite Sprite;

typedef enum  {
	COLLISION_X,
	COLLISION_Y,
	COLLISION_CORNER
} Collision;

typedef enum  {
	ACTOR_DEFAULT,
	ACTOR_BACKGROUND,
	ACTOR_TEXT,
	ACTOR_PLAYER,
	ACTOR_BONUS,
	ACTOR_HUD
} Actor;

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_PLAYER,
	CATEGORY_BONUS
} Category;

struct _Point2d {
	gdouble x;
	gdouble y;
};

struct _Vector2d {
	gdouble x;
	gdouble y;
};

struct _Timer {
	gint begin;
	gint finish;
	gint best;
};

struct _Health {
	gint curHealth;
	gint maxHealth;
};

struct _Entity {
	gint id;
	gchar* name;
	gboolean active;
	Category category;
	Actor actor;
	Point2d position;
	SDL_Rect bounds;
	sdxgraphicsSprite* sprite;
	Vector2d* size;
	Vector2d* scale;
	SDL_Color* tint;
	Timer* expires;
	Health* health;
	Vector2d* velocity;
};

struct _Blit {
	SDL_Rect source;
	SDL_Rect dest;
	SDL_RendererFlip flip;
};

struct _ScaleTween {
	gdouble min;
	gdouble max;
	gdouble speed;
	gboolean repeat;
	gboolean active;
};

struct _Sprite {
	SDL_Texture* texture;
	gint width;
	gint height;
};



gdouble clamp (gdouble value, gdouble low, gdouble hi);
GType collision_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
GType entity_get_type (void) G_GNUC_CONST;
GType point2d_get_type (void) G_GNUC_CONST;
Point2d* point2d_dup (const Point2d* self);
void point2d_free (Point2d* self);
void sdx_graphics_sprite_free (sdxgraphicsSprite* self);
GType vector2d_get_type (void) G_GNUC_CONST;
Vector2d* vector2d_dup (const Vector2d* self);
void vector2d_free (Vector2d* self);
GType timer_get_type (void) G_GNUC_CONST;
Timer* timer_dup (const Timer* self);
void timer_free (Timer* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
static SDL_Color* _sdl_video_color_dup (SDL_Color* self);
GType blit_get_type (void) G_GNUC_CONST;
Blit* blit_dup (const Blit* self);
void blit_free (Blit* self);
void blit (SDL_Rect* source, SDL_Rect* dest, SDL_RendererFlip flip, Blit* result);
void timer (gint begin, gint finish, gint best, Timer* result);
GType scale_tween_get_type (void) G_GNUC_CONST;
ScaleTween* scale_tween_dup (const ScaleTween* self);
void scale_tween_free (ScaleTween* self);
void scaletween (gdouble min, gdouble max, gdouble speed, gboolean repeat, gboolean active, ScaleTween* result);
GType sprite_get_type (void) G_GNUC_CONST;
Sprite* sprite_dup (const Sprite* self);
void sprite_free (Sprite* self);
void sprite (SDL_Texture* texture, gint width, gint height, Sprite* result);
void point2d_add (Point2d *self, Vector2d* v, Point2d* result);
void point2d (gdouble x, gdouble y, Point2d* result);
void point2d_sub (Point2d *self, Vector2d* v, Point2d* result);
void vector2d_mul (Vector2d *self, gdouble f, Vector2d* result);
void vector2d (gdouble x, gdouble y, Vector2d* result);
void vector2d_div (Vector2d *self, gdouble f, Vector2d* result);
gdouble vector2d_len (Vector2d *self);
void health (gint curHealth, gint maxHealth, Health* result);
void rect (gint x, gint y, gint h, gint w, SDL_Rect* result);
SDL_Color color (guint8 r, guint8 g, guint8 b, guint8 a);


inline gdouble clamp (gdouble value, gdouble low, gdouble hi) {
	gdouble result = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	_tmp1_ = value;
	_tmp2_ = low;
	if (_tmp1_ < _tmp2_) {
		gdouble _tmp3_ = 0.0;
		_tmp3_ = low;
		_tmp0_ = _tmp3_;
	} else {
		gdouble _tmp4_ = 0.0;
		gdouble _tmp5_ = 0.0;
		gdouble _tmp6_ = 0.0;
		_tmp5_ = value;
		_tmp6_ = hi;
		if (_tmp5_ > _tmp6_) {
			gdouble _tmp7_ = 0.0;
			_tmp7_ = hi;
			_tmp4_ = _tmp7_;
		} else {
			gdouble _tmp8_ = 0.0;
			_tmp8_ = value;
			_tmp4_ = _tmp8_;
		}
		_tmp0_ = _tmp4_;
	}
	result = _tmp0_;
	return result;
}


GType collision_get_type (void) {
	static volatile gsize collision_type_id__volatile = 0;
	if (g_once_init_enter (&collision_type_id__volatile)) {
		static const GEnumValue values[] = {{COLLISION_X, "COLLISION_X", "x"}, {COLLISION_Y, "COLLISION_Y", "y"}, {COLLISION_CORNER, "COLLISION_CORNER", "corner"}, {0, NULL, NULL}};
		GType collision_type_id;
		collision_type_id = g_enum_register_static ("Collision", values);
		g_once_init_leave (&collision_type_id__volatile, collision_type_id);
	}
	return collision_type_id__volatile;
}


GType actor_get_type (void) {
	static volatile gsize actor_type_id__volatile = 0;
	if (g_once_init_enter (&actor_type_id__volatile)) {
		static const GEnumValue values[] = {{ACTOR_DEFAULT, "ACTOR_DEFAULT", "default"}, {ACTOR_BACKGROUND, "ACTOR_BACKGROUND", "background"}, {ACTOR_TEXT, "ACTOR_TEXT", "text"}, {ACTOR_PLAYER, "ACTOR_PLAYER", "player"}, {ACTOR_BONUS, "ACTOR_BONUS", "bonus"}, {ACTOR_HUD, "ACTOR_HUD", "hud"}, {0, NULL, NULL}};
		GType actor_type_id;
		actor_type_id = g_enum_register_static ("Actor", values);
		g_once_init_leave (&actor_type_id__volatile, actor_type_id);
	}
	return actor_type_id__volatile;
}


GType category_get_type (void) {
	static volatile gsize category_type_id__volatile = 0;
	if (g_once_init_enter (&category_type_id__volatile)) {
		static const GEnumValue values[] = {{CATEGORY_BACKGROUND, "CATEGORY_BACKGROUND", "background"}, {CATEGORY_PLAYER, "CATEGORY_PLAYER", "player"}, {CATEGORY_BONUS, "CATEGORY_BONUS", "bonus"}, {0, NULL, NULL}};
		GType category_type_id;
		category_type_id = g_enum_register_static ("Category", values);
		g_once_init_leave (&category_type_id__volatile, category_type_id);
	}
	return category_type_id__volatile;
}


static gpointer _sdx_graphics_sprite_retain0 (gpointer self) {
	return self ? sdx_graphics_sprite_retain (self) : NULL;
}


static gpointer _vector2d_dup0 (gpointer self) {
	return self ? vector2d_dup (self) : NULL;
}


static SDL_Color* _sdl_video_color_dup (SDL_Color* self) {
	SDL_Color* dup;
	dup = g_new0 (SDL_Color, 1);
	memcpy (dup, self, sizeof (SDL_Color));
	return dup;
}


static gpointer __sdl_video_color_dup0 (gpointer self) {
	return self ? _sdl_video_color_dup (self) : NULL;
}


static gpointer _timer_dup0 (gpointer self) {
	return self ? timer_dup (self) : NULL;
}


static gpointer _health_dup0 (gpointer self) {
	return self ? health_dup (self) : NULL;
}


void entity_copy (const Entity* self, Entity* dest) {
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	Category _tmp4_ = 0;
	Actor _tmp5_ = 0;
	Point2d _tmp6_ = {0};
	SDL_Rect _tmp7_ = {0};
	sdxgraphicsSprite* _tmp8_ = NULL;
	sdxgraphicsSprite* _tmp9_ = NULL;
	Vector2d* _tmp10_ = NULL;
	Vector2d* _tmp11_ = NULL;
	Vector2d* _tmp12_ = NULL;
	Vector2d* _tmp13_ = NULL;
	SDL_Color* _tmp14_ = NULL;
	SDL_Color* _tmp15_ = NULL;
	Timer* _tmp16_ = NULL;
	Timer* _tmp17_ = NULL;
	Health* _tmp18_ = NULL;
	Health* _tmp19_ = NULL;
	Vector2d* _tmp20_ = NULL;
	Vector2d* _tmp21_ = NULL;
	_tmp0_ = (*self).id;
	(*dest).id = _tmp0_;
	_tmp1_ = (*self).name;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp2_;
	_tmp3_ = (*self).active;
	(*dest).active = _tmp3_;
	_tmp4_ = (*self).category;
	(*dest).category = _tmp4_;
	_tmp5_ = (*self).actor;
	(*dest).actor = _tmp5_;
	_tmp6_ = (*self).position;
	(*dest).position = _tmp6_;
	_tmp7_ = (*self).bounds;
	(*dest).bounds = _tmp7_;
	_tmp8_ = (*self).sprite;
	_tmp9_ = _sdx_graphics_sprite_retain0 (_tmp8_);
	_sdx_graphics_sprite_release0 ((*dest).sprite);
	(*dest).sprite = _tmp9_;
	_tmp10_ = (*self).size;
	_tmp11_ = _vector2d_dup0 (_tmp10_);
	_vector2d_free0 ((*dest).size);
	(*dest).size = _tmp11_;
	_tmp12_ = (*self).scale;
	_tmp13_ = _vector2d_dup0 (_tmp12_);
	_vector2d_free0 ((*dest).scale);
	(*dest).scale = _tmp13_;
	_tmp14_ = (*self).tint;
	_tmp15_ = __sdl_video_color_dup0 (_tmp14_);
	_g_free0 ((*dest).tint);
	(*dest).tint = _tmp15_;
	_tmp16_ = (*self).expires;
	_tmp17_ = _timer_dup0 (_tmp16_);
	_timer_free0 ((*dest).expires);
	(*dest).expires = _tmp17_;
	_tmp18_ = (*self).health;
	_tmp19_ = _health_dup0 (_tmp18_);
	_health_free0 ((*dest).health);
	(*dest).health = _tmp19_;
	_tmp20_ = (*self).velocity;
	_tmp21_ = _vector2d_dup0 (_tmp20_);
	_vector2d_free0 ((*dest).velocity);
	(*dest).velocity = _tmp21_;
}


void entity_destroy (Entity* self) {
	_g_free0 ((*self).name);
	_sdx_graphics_sprite_release0 ((*self).sprite);
	_vector2d_free0 ((*self).size);
	_vector2d_free0 ((*self).scale);
	_g_free0 ((*self).tint);
	_timer_free0 ((*self).expires);
	_health_free0 ((*self).health);
	_vector2d_free0 ((*self).velocity);
}


Entity* entity_dup (const Entity* self) {
	Entity* dup;
	dup = g_new0 (Entity, 1);
	entity_copy (self, dup);
	return dup;
}


void entity_free (Entity* self) {
	entity_destroy (self);
	g_free (self);
}


GType entity_get_type (void) {
	static volatile gsize entity_type_id__volatile = 0;
	if (g_once_init_enter (&entity_type_id__volatile)) {
		GType entity_type_id;
		entity_type_id = g_boxed_type_register_static ("Entity", (GBoxedCopyFunc) entity_dup, (GBoxedFreeFunc) entity_free);
		g_once_init_leave (&entity_type_id__volatile, entity_type_id);
	}
	return entity_type_id__volatile;
}


Blit* blit_dup (const Blit* self) {
	Blit* dup;
	dup = g_new0 (Blit, 1);
	memcpy (dup, self, sizeof (Blit));
	return dup;
}


void blit_free (Blit* self) {
	g_free (self);
}


GType blit_get_type (void) {
	static volatile gsize blit_type_id__volatile = 0;
	if (g_once_init_enter (&blit_type_id__volatile)) {
		GType blit_type_id;
		blit_type_id = g_boxed_type_register_static ("Blit", (GBoxedCopyFunc) blit_dup, (GBoxedFreeFunc) blit_free);
		g_once_init_leave (&blit_type_id__volatile, blit_type_id);
	}
	return blit_type_id__volatile;
}


void blit (SDL_Rect* source, SDL_Rect* dest, SDL_RendererFlip flip, Blit* result) {
	SDL_Rect _tmp0_ = {0};
	SDL_Rect _tmp1_ = {0};
	SDL_RendererFlip _tmp2_ = 0;
	Blit _tmp3_ = {0};
	g_return_if_fail (source != NULL);
	g_return_if_fail (dest != NULL);
	_tmp0_ = *source;
	_tmp1_ = *dest;
	_tmp2_ = flip;
	_tmp3_.source = _tmp0_;
	_tmp3_.dest = _tmp1_;
	_tmp3_.flip = _tmp2_;
	*result = _tmp3_;
	return;
}


Timer* timer_dup (const Timer* self) {
	Timer* dup;
	dup = g_new0 (Timer, 1);
	memcpy (dup, self, sizeof (Timer));
	return dup;
}


void timer_free (Timer* self) {
	g_free (self);
}


GType timer_get_type (void) {
	static volatile gsize timer_type_id__volatile = 0;
	if (g_once_init_enter (&timer_type_id__volatile)) {
		GType timer_type_id;
		timer_type_id = g_boxed_type_register_static ("Timer", (GBoxedCopyFunc) timer_dup, (GBoxedFreeFunc) timer_free);
		g_once_init_leave (&timer_type_id__volatile, timer_type_id);
	}
	return timer_type_id__volatile;
}


void timer (gint begin, gint finish, gint best, Timer* result) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	Timer _tmp3_ = {0};
	_tmp0_ = begin;
	_tmp1_ = finish;
	_tmp2_ = best;
	_tmp3_.begin = _tmp0_;
	_tmp3_.finish = _tmp1_;
	_tmp3_.best = _tmp2_;
	*result = _tmp3_;
	return;
}


ScaleTween* scale_tween_dup (const ScaleTween* self) {
	ScaleTween* dup;
	dup = g_new0 (ScaleTween, 1);
	memcpy (dup, self, sizeof (ScaleTween));
	return dup;
}


void scale_tween_free (ScaleTween* self) {
	g_free (self);
}


GType scale_tween_get_type (void) {
	static volatile gsize scale_tween_type_id__volatile = 0;
	if (g_once_init_enter (&scale_tween_type_id__volatile)) {
		GType scale_tween_type_id;
		scale_tween_type_id = g_boxed_type_register_static ("ScaleTween", (GBoxedCopyFunc) scale_tween_dup, (GBoxedFreeFunc) scale_tween_free);
		g_once_init_leave (&scale_tween_type_id__volatile, scale_tween_type_id);
	}
	return scale_tween_type_id__volatile;
}


void scaletween (gdouble min, gdouble max, gdouble speed, gboolean repeat, gboolean active, ScaleTween* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	ScaleTween _tmp5_ = {0};
	_tmp0_ = min;
	_tmp1_ = max;
	_tmp2_ = speed;
	_tmp3_ = repeat;
	_tmp4_ = active;
	_tmp5_.min = _tmp0_;
	_tmp5_.max = _tmp1_;
	_tmp5_.speed = _tmp2_;
	_tmp5_.repeat = _tmp3_;
	_tmp5_.active = _tmp4_;
	*result = _tmp5_;
	return;
}


Sprite* sprite_dup (const Sprite* self) {
	Sprite* dup;
	dup = g_new0 (Sprite, 1);
	memcpy (dup, self, sizeof (Sprite));
	return dup;
}


void sprite_free (Sprite* self) {
	g_free (self);
}


GType sprite_get_type (void) {
	static volatile gsize sprite_type_id__volatile = 0;
	if (g_once_init_enter (&sprite_type_id__volatile)) {
		GType sprite_type_id;
		sprite_type_id = g_boxed_type_register_static ("Sprite", (GBoxedCopyFunc) sprite_dup, (GBoxedFreeFunc) sprite_free);
		g_once_init_leave (&sprite_type_id__volatile, sprite_type_id);
	}
	return sprite_type_id__volatile;
}


void sprite (SDL_Texture* texture, gint width, gint height, Sprite* result) {
	SDL_Texture* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	Sprite _tmp3_ = {0};
	g_return_if_fail (texture != NULL);
	_tmp0_ = texture;
	_tmp1_ = width;
	_tmp2_ = height;
	_tmp3_.texture = _tmp0_;
	_tmp3_.width = _tmp1_;
	_tmp3_.height = _tmp2_;
	*result = _tmp3_;
	return;
}


inline void point2d_add (Point2d *self, Vector2d* v, Point2d* result) {
	gdouble _tmp0_ = 0.0;
	Vector2d _tmp1_ = {0};
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	Point2d _tmp6_ = {0};
	g_return_if_fail (v != NULL);
	_tmp0_ = (*self).x;
	_tmp1_ = *v;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = (*self).y;
	_tmp4_ = *v;
	_tmp5_ = _tmp4_.y;
	point2d (_tmp0_ + _tmp2_, _tmp3_ + _tmp5_, &_tmp6_);
	*result = _tmp6_;
	return;
}


inline void point2d_sub (Point2d *self, Vector2d* v, Point2d* result) {
	gdouble _tmp0_ = 0.0;
	Vector2d _tmp1_ = {0};
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	Point2d _tmp6_ = {0};
	g_return_if_fail (v != NULL);
	_tmp0_ = (*self).x;
	_tmp1_ = *v;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = (*self).y;
	_tmp4_ = *v;
	_tmp5_ = _tmp4_.y;
	point2d (_tmp0_ - _tmp2_, _tmp3_ - _tmp5_, &_tmp6_);
	*result = _tmp6_;
	return;
}


Point2d* point2d_dup (const Point2d* self) {
	Point2d* dup;
	dup = g_new0 (Point2d, 1);
	memcpy (dup, self, sizeof (Point2d));
	return dup;
}


void point2d_free (Point2d* self) {
	g_free (self);
}


GType point2d_get_type (void) {
	static volatile gsize point2d_type_id__volatile = 0;
	if (g_once_init_enter (&point2d_type_id__volatile)) {
		GType point2d_type_id;
		point2d_type_id = g_boxed_type_register_static ("Point2d", (GBoxedCopyFunc) point2d_dup, (GBoxedFreeFunc) point2d_free);
		g_once_init_leave (&point2d_type_id__volatile, point2d_type_id);
	}
	return point2d_type_id__volatile;
}


void point2d (gdouble x, gdouble y, Point2d* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	Point2d _tmp2_ = {0};
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_.x = _tmp0_;
	_tmp2_.y = _tmp1_;
	*result = _tmp2_;
	return;
}


inline void vector2d_mul (Vector2d *self, gdouble f, Vector2d* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	_tmp0_ = (*self).x;
	_tmp1_ = f;
	_tmp2_ = (*self).y;
	_tmp3_ = f;
	vector2d (_tmp0_ * _tmp1_, _tmp2_ * _tmp3_, &_tmp4_);
	*result = _tmp4_;
	return;
}


inline void vector2d_div (Vector2d *self, gdouble f, Vector2d* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	Vector2d _tmp4_ = {0};
	_tmp0_ = (*self).x;
	_tmp1_ = f;
	_tmp2_ = (*self).y;
	_tmp3_ = f;
	vector2d (_tmp0_ / _tmp1_, _tmp2_ / _tmp3_, &_tmp4_);
	*result = _tmp4_;
	return;
}


inline gdouble vector2d_len (Vector2d *self) {
	gdouble result = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	_tmp0_ = (*self).x;
	_tmp1_ = (*self).x;
	_tmp2_ = (*self).y;
	_tmp3_ = (*self).y;
	_tmp4_ = sqrt ((_tmp0_ * _tmp1_) + (_tmp2_ * _tmp3_));
	result = _tmp4_;
	return result;
}


Vector2d* vector2d_dup (const Vector2d* self) {
	Vector2d* dup;
	dup = g_new0 (Vector2d, 1);
	memcpy (dup, self, sizeof (Vector2d));
	return dup;
}


void vector2d_free (Vector2d* self) {
	g_free (self);
}


GType vector2d_get_type (void) {
	static volatile gsize vector2d_type_id__volatile = 0;
	if (g_once_init_enter (&vector2d_type_id__volatile)) {
		GType vector2d_type_id;
		vector2d_type_id = g_boxed_type_register_static ("Vector2d", (GBoxedCopyFunc) vector2d_dup, (GBoxedFreeFunc) vector2d_free);
		g_once_init_leave (&vector2d_type_id__volatile, vector2d_type_id);
	}
	return vector2d_type_id__volatile;
}


void vector2d (gdouble x, gdouble y, Vector2d* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	Vector2d _tmp2_ = {0};
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_.x = _tmp0_;
	_tmp2_.y = _tmp1_;
	*result = _tmp2_;
	return;
}


Health* health_dup (const Health* self) {
	Health* dup;
	dup = g_new0 (Health, 1);
	memcpy (dup, self, sizeof (Health));
	return dup;
}


void health_free (Health* self) {
	g_free (self);
}


GType health_get_type (void) {
	static volatile gsize health_type_id__volatile = 0;
	if (g_once_init_enter (&health_type_id__volatile)) {
		GType health_type_id;
		health_type_id = g_boxed_type_register_static ("Health", (GBoxedCopyFunc) health_dup, (GBoxedFreeFunc) health_free);
		g_once_init_leave (&health_type_id__volatile, health_type_id);
	}
	return health_type_id__volatile;
}


void health (gint curHealth, gint maxHealth, Health* result) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	Health _tmp2_ = {0};
	_tmp0_ = curHealth;
	_tmp1_ = maxHealth;
	_tmp2_.curHealth = _tmp0_;
	_tmp2_.maxHealth = _tmp1_;
	*result = _tmp2_;
	return;
}


/**
 * Component constructor helpers
 */
void rect (gint x, gint y, gint h, gint w, SDL_Rect* result) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	SDL_Rect _tmp4_ = {0};
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_ = h;
	_tmp3_ = w;
	_tmp4_.x = _tmp0_;
	_tmp4_.y = _tmp1_;
	_tmp4_.w = (guint) _tmp2_;
	_tmp4_.h = (guint) _tmp3_;
	*result = _tmp4_;
	return;
}


SDL_Color color (guint8 r, guint8 g, guint8 b, guint8 a) {
	SDL_Color result = {0};
	guint8 _tmp0_ = 0U;
	guint8 _tmp1_ = 0U;
	guint8 _tmp2_ = 0U;
	guint8 _tmp3_ = 0U;
	SDL_Color _tmp4_ = {0};
	_tmp0_ = r;
	_tmp1_ = g;
	_tmp2_ = b;
	_tmp3_ = a;
	_tmp4_.r = _tmp0_;
	_tmp4_.g = _tmp1_;
	_tmp4_.b = _tmp2_;
	_tmp4_.a = _tmp3_;
	result = _tmp4_;
	return result;
}



