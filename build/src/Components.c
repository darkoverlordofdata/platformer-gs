/* Components.c generated by valac 0.34.8, the Vala compiler
 * generated from Components.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <SDL2/SDL_rect.h>
#include <SDL2/SDL_pixels.h>


#define TYPE_COLLISION (collision_get_type ())

#define TYPE_ACTOR (actor_get_type ())

#define TYPE_CATEGORY (category_get_type ())

#define TYPE_TIMER (timer_get_type ())
typedef struct _Timer Timer;

#define TYPE_SCALE_TWEEN (scale_tween_get_type ())
typedef struct _ScaleTween ScaleTween;

#define TYPE_HEALTH (health_get_type ())
typedef struct _Health Health;

#define TYPE_ENTITY (entity_get_type ())

#define SDX_MATH_TYPE_VECTOR2 (sdx_math_vector2_get_type ())
typedef struct _sdxmathVector2 sdxmathVector2;

#define SDX_GRAPHICS_TYPE_RECT (sdx_graphics_rect_get_type ())
typedef SDL_Rect sdxgraphicsRect;
typedef struct _sdxgraphicsSprite sdxgraphicsSprite;

#define SDX_GRAPHICS_TYPE_COLOR (sdx_graphics_color_get_type ())
typedef SDL_Color sdxgraphicsColor;
typedef struct _Entity Entity;
#define _g_free0(var) (var = (g_free (var), NULL))
void sdx_graphics_sprite_release (sdxgraphicsSprite* self);
void sdx_graphics_sprite_free (sdxgraphicsSprite* self);
sdxgraphicsSprite* sdx_graphics_sprite_retain (sdxgraphicsSprite* self);
#define _sdx_graphics_sprite_release0(var) ((var == NULL) ? NULL : (var = (sdx_graphics_sprite_release (var), NULL)))
#define _sdx_math_vector2_free0(var) ((var == NULL) ? NULL : (var = (sdx_math_vector2_free (var), NULL)))
#define _sdx_graphics_color_free0(var) ((var == NULL) ? NULL : (var = (sdx_graphics_color_free (var), NULL)))
#define _timer_free0(var) ((var == NULL) ? NULL : (var = (timer_free (var), NULL)))
#define _health_free0(var) ((var == NULL) ? NULL : (var = (health_free (var), NULL)))

typedef enum  {
	COLLISION_X,
	COLLISION_Y,
	COLLISION_CORNER
} Collision;

typedef enum  {
	ACTOR_DEFAULT,
	ACTOR_BACKGROUND,
	ACTOR_TEXT,
	ACTOR_PLAYER,
	ACTOR_BONUS,
	ACTOR_HUD
} Actor;

typedef enum  {
	CATEGORY_BACKGROUND,
	CATEGORY_PLAYER,
	CATEGORY_BONUS
} Category;

struct _Timer {
	gint begin;
	gint finish;
	gint best;
};

struct _ScaleTween {
	gfloat min;
	gfloat max;
	gfloat speed;
	gboolean repeat;
	gboolean active;
};

struct _Health {
	gint curHealth;
	gint maxHealth;
};

struct _sdxmathVector2 {
	gfloat x;
	gfloat y;
};

struct _Entity {
	gint id;
	gchar* name;
	gboolean active;
	Category category;
	Actor actor;
	sdxmathVector2 position;
	sdxgraphicsRect bounds;
	sdxgraphicsSprite* sprite;
	sdxmathVector2* size;
	sdxmathVector2* scale;
	sdxgraphicsColor* tint;
	Timer* expires;
	Health* health;
	sdxmathVector2* velocity;
};



GType collision_get_type (void) G_GNUC_CONST;
GType actor_get_type (void) G_GNUC_CONST;
GType category_get_type (void) G_GNUC_CONST;
GType timer_get_type (void) G_GNUC_CONST;
Timer* timer_dup (const Timer* self);
void timer_free (Timer* self);
GType scale_tween_get_type (void) G_GNUC_CONST;
ScaleTween* scale_tween_dup (const ScaleTween* self);
void scale_tween_free (ScaleTween* self);
GType health_get_type (void) G_GNUC_CONST;
Health* health_dup (const Health* self);
void health_free (Health* self);
GType entity_get_type (void) G_GNUC_CONST;
GType sdx_math_vector2_get_type (void) G_GNUC_CONST;
sdxmathVector2* sdx_math_vector2_dup (const sdxmathVector2* self);
void sdx_math_vector2_free (sdxmathVector2* self);
GType sdx_graphics_rect_get_type (void) G_GNUC_CONST;
sdxgraphicsRect* sdx_graphics_rect_dup (const sdxgraphicsRect* self);
void sdx_graphics_rect_free (sdxgraphicsRect* self);
void sdx_graphics_sprite_free (sdxgraphicsSprite* self);
GType sdx_graphics_color_get_type (void) G_GNUC_CONST;
sdxgraphicsColor* sdx_graphics_color_dup (const sdxgraphicsColor* self);
void sdx_graphics_color_free (sdxgraphicsColor* self);
Entity* entity_dup (const Entity* self);
void entity_free (Entity* self);
void entity_copy (const Entity* self, Entity* dest);
void entity_destroy (Entity* self);
void rect (gint x, gint y, gint h, gint w, SDL_Rect* result);
SDL_Color color (guint8 r, guint8 g, guint8 b, guint8 a);


GType collision_get_type (void) {
	static volatile gsize collision_type_id__volatile = 0;
	if (g_once_init_enter (&collision_type_id__volatile)) {
		static const GEnumValue values[] = {{COLLISION_X, "COLLISION_X", "x"}, {COLLISION_Y, "COLLISION_Y", "y"}, {COLLISION_CORNER, "COLLISION_CORNER", "corner"}, {0, NULL, NULL}};
		GType collision_type_id;
		collision_type_id = g_enum_register_static ("Collision", values);
		g_once_init_leave (&collision_type_id__volatile, collision_type_id);
	}
	return collision_type_id__volatile;
}


GType actor_get_type (void) {
	static volatile gsize actor_type_id__volatile = 0;
	if (g_once_init_enter (&actor_type_id__volatile)) {
		static const GEnumValue values[] = {{ACTOR_DEFAULT, "ACTOR_DEFAULT", "default"}, {ACTOR_BACKGROUND, "ACTOR_BACKGROUND", "background"}, {ACTOR_TEXT, "ACTOR_TEXT", "text"}, {ACTOR_PLAYER, "ACTOR_PLAYER", "player"}, {ACTOR_BONUS, "ACTOR_BONUS", "bonus"}, {ACTOR_HUD, "ACTOR_HUD", "hud"}, {0, NULL, NULL}};
		GType actor_type_id;
		actor_type_id = g_enum_register_static ("Actor", values);
		g_once_init_leave (&actor_type_id__volatile, actor_type_id);
	}
	return actor_type_id__volatile;
}


GType category_get_type (void) {
	static volatile gsize category_type_id__volatile = 0;
	if (g_once_init_enter (&category_type_id__volatile)) {
		static const GEnumValue values[] = {{CATEGORY_BACKGROUND, "CATEGORY_BACKGROUND", "background"}, {CATEGORY_PLAYER, "CATEGORY_PLAYER", "player"}, {CATEGORY_BONUS, "CATEGORY_BONUS", "bonus"}, {0, NULL, NULL}};
		GType category_type_id;
		category_type_id = g_enum_register_static ("Category", values);
		g_once_init_leave (&category_type_id__volatile, category_type_id);
	}
	return category_type_id__volatile;
}


Timer* timer_dup (const Timer* self) {
	Timer* dup;
	dup = g_new0 (Timer, 1);
	memcpy (dup, self, sizeof (Timer));
	return dup;
}


void timer_free (Timer* self) {
	g_free (self);
}


GType timer_get_type (void) {
	static volatile gsize timer_type_id__volatile = 0;
	if (g_once_init_enter (&timer_type_id__volatile)) {
		GType timer_type_id;
		timer_type_id = g_boxed_type_register_static ("Timer", (GBoxedCopyFunc) timer_dup, (GBoxedFreeFunc) timer_free);
		g_once_init_leave (&timer_type_id__volatile, timer_type_id);
	}
	return timer_type_id__volatile;
}


ScaleTween* scale_tween_dup (const ScaleTween* self) {
	ScaleTween* dup;
	dup = g_new0 (ScaleTween, 1);
	memcpy (dup, self, sizeof (ScaleTween));
	return dup;
}


void scale_tween_free (ScaleTween* self) {
	g_free (self);
}


GType scale_tween_get_type (void) {
	static volatile gsize scale_tween_type_id__volatile = 0;
	if (g_once_init_enter (&scale_tween_type_id__volatile)) {
		GType scale_tween_type_id;
		scale_tween_type_id = g_boxed_type_register_static ("ScaleTween", (GBoxedCopyFunc) scale_tween_dup, (GBoxedFreeFunc) scale_tween_free);
		g_once_init_leave (&scale_tween_type_id__volatile, scale_tween_type_id);
	}
	return scale_tween_type_id__volatile;
}


Health* health_dup (const Health* self) {
	Health* dup;
	dup = g_new0 (Health, 1);
	memcpy (dup, self, sizeof (Health));
	return dup;
}


void health_free (Health* self) {
	g_free (self);
}


GType health_get_type (void) {
	static volatile gsize health_type_id__volatile = 0;
	if (g_once_init_enter (&health_type_id__volatile)) {
		GType health_type_id;
		health_type_id = g_boxed_type_register_static ("Health", (GBoxedCopyFunc) health_dup, (GBoxedFreeFunc) health_free);
		g_once_init_leave (&health_type_id__volatile, health_type_id);
	}
	return health_type_id__volatile;
}


static gpointer _sdx_graphics_sprite_retain0 (gpointer self) {
	return self ? sdx_graphics_sprite_retain (self) : NULL;
}


static gpointer _sdx_math_vector2_dup0 (gpointer self) {
	return self ? sdx_math_vector2_dup (self) : NULL;
}


static gpointer _sdx_graphics_color_dup0 (gpointer self) {
	return self ? sdx_graphics_color_dup (self) : NULL;
}


static gpointer _timer_dup0 (gpointer self) {
	return self ? timer_dup (self) : NULL;
}


static gpointer _health_dup0 (gpointer self) {
	return self ? health_dup (self) : NULL;
}


void entity_copy (const Entity* self, Entity* dest) {
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	Category _tmp4_ = 0;
	Actor _tmp5_ = 0;
	sdxmathVector2 _tmp6_ = {0};
	sdxgraphicsRect _tmp7_ = {0};
	sdxgraphicsSprite* _tmp8_ = NULL;
	sdxgraphicsSprite* _tmp9_ = NULL;
	sdxmathVector2* _tmp10_ = NULL;
	sdxmathVector2* _tmp11_ = NULL;
	sdxmathVector2* _tmp12_ = NULL;
	sdxmathVector2* _tmp13_ = NULL;
	sdxgraphicsColor* _tmp14_ = NULL;
	sdxgraphicsColor* _tmp15_ = NULL;
	Timer* _tmp16_ = NULL;
	Timer* _tmp17_ = NULL;
	Health* _tmp18_ = NULL;
	Health* _tmp19_ = NULL;
	sdxmathVector2* _tmp20_ = NULL;
	sdxmathVector2* _tmp21_ = NULL;
	_tmp0_ = (*self).id;
	(*dest).id = _tmp0_;
	_tmp1_ = (*self).name;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp2_;
	_tmp3_ = (*self).active;
	(*dest).active = _tmp3_;
	_tmp4_ = (*self).category;
	(*dest).category = _tmp4_;
	_tmp5_ = (*self).actor;
	(*dest).actor = _tmp5_;
	_tmp6_ = (*self).position;
	(*dest).position = _tmp6_;
	_tmp7_ = (*self).bounds;
	(*dest).bounds = _tmp7_;
	_tmp8_ = (*self).sprite;
	_tmp9_ = _sdx_graphics_sprite_retain0 (_tmp8_);
	_sdx_graphics_sprite_release0 ((*dest).sprite);
	(*dest).sprite = _tmp9_;
	_tmp10_ = (*self).size;
	_tmp11_ = _sdx_math_vector2_dup0 (_tmp10_);
	_sdx_math_vector2_free0 ((*dest).size);
	(*dest).size = _tmp11_;
	_tmp12_ = (*self).scale;
	_tmp13_ = _sdx_math_vector2_dup0 (_tmp12_);
	_sdx_math_vector2_free0 ((*dest).scale);
	(*dest).scale = _tmp13_;
	_tmp14_ = (*self).tint;
	_tmp15_ = _sdx_graphics_color_dup0 (_tmp14_);
	_sdx_graphics_color_free0 ((*dest).tint);
	(*dest).tint = _tmp15_;
	_tmp16_ = (*self).expires;
	_tmp17_ = _timer_dup0 (_tmp16_);
	_timer_free0 ((*dest).expires);
	(*dest).expires = _tmp17_;
	_tmp18_ = (*self).health;
	_tmp19_ = _health_dup0 (_tmp18_);
	_health_free0 ((*dest).health);
	(*dest).health = _tmp19_;
	_tmp20_ = (*self).velocity;
	_tmp21_ = _sdx_math_vector2_dup0 (_tmp20_);
	_sdx_math_vector2_free0 ((*dest).velocity);
	(*dest).velocity = _tmp21_;
}


void entity_destroy (Entity* self) {
	_g_free0 ((*self).name);
	_sdx_graphics_sprite_release0 ((*self).sprite);
	_sdx_math_vector2_free0 ((*self).size);
	_sdx_math_vector2_free0 ((*self).scale);
	_sdx_graphics_color_free0 ((*self).tint);
	_timer_free0 ((*self).expires);
	_health_free0 ((*self).health);
	_sdx_math_vector2_free0 ((*self).velocity);
}


Entity* entity_dup (const Entity* self) {
	Entity* dup;
	dup = g_new0 (Entity, 1);
	entity_copy (self, dup);
	return dup;
}


void entity_free (Entity* self) {
	entity_destroy (self);
	g_free (self);
}


GType entity_get_type (void) {
	static volatile gsize entity_type_id__volatile = 0;
	if (g_once_init_enter (&entity_type_id__volatile)) {
		GType entity_type_id;
		entity_type_id = g_boxed_type_register_static ("Entity", (GBoxedCopyFunc) entity_dup, (GBoxedFreeFunc) entity_free);
		g_once_init_leave (&entity_type_id__volatile, entity_type_id);
	}
	return entity_type_id__volatile;
}


inline void rect (gint x, gint y, gint h, gint w, SDL_Rect* result) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	SDL_Rect _tmp4_ = {0};
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_ = h;
	_tmp3_ = w;
	_tmp4_.x = _tmp0_;
	_tmp4_.y = _tmp1_;
	_tmp4_.w = (guint) _tmp2_;
	_tmp4_.h = (guint) _tmp3_;
	*result = _tmp4_;
	return;
}


inline SDL_Color color (guint8 r, guint8 g, guint8 b, guint8 a) {
	SDL_Color result = {0};
	guint8 _tmp0_ = 0U;
	guint8 _tmp1_ = 0U;
	guint8 _tmp2_ = 0U;
	guint8 _tmp3_ = 0U;
	SDL_Color _tmp4_ = {0};
	_tmp0_ = r;
	_tmp1_ = g;
	_tmp2_ = b;
	_tmp3_ = a;
	_tmp4_.r = _tmp0_;
	_tmp4_.g = _tmp1_;
	_tmp4_.b = _tmp2_;
	_tmp4_.a = _tmp3_;
	result = _tmp4_;
	return result;
}



